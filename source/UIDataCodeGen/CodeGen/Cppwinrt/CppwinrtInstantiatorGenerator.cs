// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using Microsoft.Toolkit.Uwp.UI.Lottie.WinCompData;
using Microsoft.Toolkit.Uwp.UI.Lottie.WinCompData.MetaData;
using Microsoft.Toolkit.Uwp.UI.Lottie.WinCompData.Mgcg;
using Microsoft.Toolkit.Uwp.UI.Lottie.WinUIXamlMediaData;
using Mgce = Microsoft.Toolkit.Uwp.UI.Lottie.WinCompData.Mgce;

namespace Microsoft.Toolkit.Uwp.UI.Lottie.UIData.CodeGen.Cppwinrt
{
    /// <summary>
    /// Generates code for use by CppWinrt.
    /// </summary>
#if PUBLIC_UIDataCodeGen
    public
#endif
    sealed class CppwinrtInstantiatorGenerator : InstantiatorGeneratorBase
    {
        const string Muxc = "winrt::Microsoft::UI::Xaml::Controls";
        readonly CppwinrtStringifier _s;
        readonly string _fileBaseName;
        readonly string _headerFileName;
        readonly string _cppFileName;
        readonly string _idlFileName;

        // The name of the source class i.e. the class
        // that contains the TryCreateAnimatedVisual method.
        readonly string _sourceClassName;
        readonly string _wuc;
        readonly string _winUINamespace;

        // The fully qualified name of the AnimatedVisual type that is returned
        // from the TryCreateAnimatedVisual method.
        readonly string _animatedVisualTypeName;

        // True iff the generated code implements IDynamicAnimatedVisualSource.
        readonly bool _isIDynamic;

        /// <summary>
        /// Returns the Cppwinrt code for a factory that will instantiate the given <see cref="Visual"/> as a
        /// Windows.UI.Composition Visual.
        /// </summary>
        /// <returns>The result of the code generation.</returns>
        public static CppwinrtCodegenResult CreateFactoryCode(CodegenConfiguration configuration)
        {
            var generator = new CppwinrtInstantiatorGenerator(configuration, new CppwinrtStringifier());

            return new CppwinrtCodegenResult
            {
                Assets = generator.GetAssetsList(),
                CppFilename = generator._cppFileName,
                CppText = generator.GenerateCode(),
                HFilename = generator._headerFileName,
                HText = generator.GenerateHeaderText(),
                IdlFilename = generator._idlFileName,
                IdlText = generator.GenerateIdlText(),
            };
        }

        CppwinrtInstantiatorGenerator(CodegenConfiguration configuration, CppwinrtStringifier stringifier)
            : base(
                  configuration: configuration,
                  setCommentProperties: false,
                  stringifier)
        {
            _s = stringifier;
            _isIDynamic = SourceInfo.LoadedImageSurfaces.Any();
            _fileBaseName = $"{SourceInfo.Namespace}.{SourceInfo.ClassName}";
            _cppFileName = $"{_fileBaseName}.cpp";
            _headerFileName = $"{_fileBaseName}.h";
            _idlFileName = $"{_fileBaseName}.idl";
            _winUINamespace = SourceInfo.WinUi3 ? "Microsoft::UI" : "Windows::UI";
            _wuc = $"{_winUINamespace}::Composition";
            _sourceClassName = SourceInfo.ClassName;
            _animatedVisualTypeName = SourceInfo.InterfaceType.GetQualifiedName(_s);
        }

        static string FieldAssignment(string fieldName) => fieldName != null ? $"{fieldName} = " : string.Empty;

        IAnimatedVisualSourceInfo SourceInfo => AnimatedVisualSourceInfo;

        /// <summary>
        /// Generates the text for the .IDL file.
        /// </summary>
        /// <returns>The text for the .IDL file.</returns>
        string GenerateIdlText()
        {
            var builder = new CodeBuilder();
            builder.WriteLine(string.Join("\r\n", AutoGeneratedHeaderText));
            if (SourceInfo.IsInterfaceCustom)
            {
                builder.WriteLine($"import \"{SourceInfo.InterfaceType.NormalizedQualifiedName}.idl\";");
                builder.WriteLine();
            }

            builder.WriteLine($"namespace {SourceInfo.Namespace}");
            builder.OpenScope();
            if (SourceInfo.IsInterfaceCustom)
            {
                builder.WriteLine("[contract(InternalContract, 1)]");
            }

            builder.WriteLine($"runtimeclass {_sourceClassName}");
            builder.Indent();
            if (SourceInfo.IsInterfaceCustom)
            {
                builder.WriteLine($": [default] {SourceInfo.InterfaceType.NormalizedQualifiedName}Source");
            }
            else
            {
                if (_isIDynamic)
                {
                    builder.WriteLine(": [default] Microsoft.UI.Xaml.Controls.IDynamicAnimatedVisualSource");
                }
                else
                {
                    builder.WriteLine(": [default] Microsoft.UI.Xaml.Controls.IAnimatedVisualSource");
                }
            }

            if (_isIDynamic)
            {
                builder.WriteLine(", Windows.UI.Xaml.Data.INotifyPropertyChanged");
            }

            builder.UnIndent();
            builder.OpenScope();
            builder.WriteLine($"{_sourceClassName}();");

            if (_isIDynamic)
            {
                // The IDynamicAnimatedVisualSource implementation has properties that
                // have to be declared in the IDL. The AnimatedVisualInvalidated event does
                // not need to be declared in IDL because it is implied by the class inheriting
                // from IDynamicAnimatedVisualSource.
                builder.WriteLine();
                builder.WriteLine("Boolean IsAnimatedVisualSourceDynamic;");
                builder.WriteLine("Boolean IsImageLoadingCompleted { get; };");
                builder.WriteLine("Double ImageSuccessfulLoadingProgress { get; };");
            }

            builder.CloseCppTypeScope();
            builder.CloseScope();
            return builder.ToString();
        }

        // Generates the .h file contents.
        string GenerateHeaderText()
        {
            // Returns the header text that implements IAnimatedVisualSource if loadedImageSurfacesNodes is null or empty.
            // Otherwise, return the header text that implements IDynamicAnimatedVisualSource.
            var builder = new HeaderBuilder();
            builder.Preamble.WriteLine("#pragma once");
            builder.Preamble.WriteLine(string.Join("\r\n", AutoGeneratedHeaderText));
            builder.Preamble.WriteLine($"#include \"{_fileBaseName}.g.h\"");

            builder.Preamble.WriteLine();
            builder.Preamble.WriteLine($"namespace winrt::{_s.Namespace(SourceInfo.Namespace)}");
            builder.Preamble.OpenScope();

            WriteSourceDescriptionComments(builder.Preamble);

            builder.Preamble.WriteLine($"namespace implementation");
            builder.Preamble.OpenScope();

            if (SourceInfo.GenerateDependencyObject)
            {
                // TODO - support dependency object generation in cppwinrt
                throw new NotImplementedException();
            }

            builder.Class.Preamble.WriteLine($"class {_sourceClassName}");
            builder.Class.Preamble.Indent();
            builder.Class.Preamble.WriteLine($": public {_sourceClassName}T<{_sourceClassName}>");
            builder.Class.Preamble.UnIndent();
            builder.Class.Preamble.OpenScope();

            WriteHeaderConstants(builder.Class.Public);

            if (SourceInfo.IsThemed)
            {
                WriteThemeHeader(builder);
            }

            if (_isIDynamic)
            {
                WriteIDynamicAnimatedVisualSourceHeaderText(builder);
            }
            else
            {
                WriteIAnimatedVisualSourceHeaderText(builder);
            }

            // Close the ::implementation namespace.
            builder.Postamble.Indent();
            builder.Postamble.CloseScope();
            builder.Postamble.WriteLine();

            // Write the factory_implementation namespace. This allows the class to be activatable.
            builder.Postamble.WriteLine("namespace factory_implementation");
            builder.Postamble.OpenScope();
            builder.Postamble.WriteLine($"struct {_sourceClassName} : {_sourceClassName}T<{_sourceClassName}, implementation::{_sourceClassName}>");
            builder.Postamble.OpenScope();
            builder.Postamble.CloseCppTypeScope();
            builder.Postamble.CloseScope();

            return builder.ToString();
        }

        IEnumerable<string> GetConstructorArguments(IAnimatedVisualInfo info)
        {
            yield return "compositor";

            if (SourceInfo.IsThemed)
            {
                yield return SourceInfo.ThemePropertiesFieldName;
            }

            foreach (var loadedImageSurfaceNode in info.LoadedImageSurfaceNodes)
            {
                yield return loadedImageSurfaceNode.FieldName;
            }
        }

        static string[] CommaSeparate(IEnumerable<string> args)
        {
            var result = args.ToArray();
            for (var i = 0; i < result.Length - 1; i++)
            {
                result[i] += ",";
            }

            return result;
        }

        static string TypeName(PropertySetValueType propertySetValueType)
            => propertySetValueType switch
            {
                PropertySetValueType.Color => "Color",
                PropertySetValueType.Scalar => "float",
                PropertySetValueType.Vector2 => "float2",
                PropertySetValueType.Vector3 => "float3",
                PropertySetValueType.Vector4 => "float4",
                _ => throw new InvalidOperationException()
            };

        // Write a description of the source as comments.
        void WriteSourceDescriptionComments(CodeBuilder builder) =>
            builder.WritePreformattedCommentLines(GetSourceDescriptionLines());

        void WriteTryCreateAnimatedVisualDeclaration(CodeBuilder builder)
        {
            builder.WriteLine($"winrt::{_animatedVisualTypeName} TryCreateAnimatedVisual(");
            builder.Indent();
            builder.WriteLine($"winrt::{_wuc}::Compositor const& compositor,");
            builder.WriteLine($"winrt::Windows::Foundation::IInspectable& diagnostics);");
            builder.UnIndent();
        }

        void WriteIAnimatedVisualSourceHeaderText(HeaderBuilder builder)
        {
            WriteTryCreateAnimatedVisualDeclaration(builder.Class.Public);

            if (SourceInfo.IsThemed)
            {
                // The GetThemeProperties method is designed to allow setting of properties when the actual
                // type of the IAnimatedVisualSource is not known.
                builder.Class.Public.WriteLine();
                builder.Class.Public.WriteLine($"winrt::{_wuc}::CompositionPropertySet GetThemeProperties(winrt::{_wuc}::Compositor compositor);");

                builder.Class.Public.WriteLine();
                builder.Class.Public.WriteLine($"static winrt::Windows::Foundation::Numerics::float4 ColorAsVector4(winrt::Windows::UI::Color color);");
            }
        }

        void WriteThemeHeader(HeaderBuilder builder)
        {
            // Add a field to hold the theme property set.
            builder.Class.Private.WriteLine($"winrt::{_wuc}::CompositionPropertySet {SourceInfo.ThemePropertiesFieldName}{{ nullptr }};");

            // Add fields for each of the theme properties.
            foreach (var prop in SourceInfo.SourceMetadata.PropertyBindings)
            {
                if (SourceInfo.GenerateDependencyObject)
                {
                    builder.Class.Private.WriteLine($"static {_winUINamespace}::Xaml::DependencyProperty^ _{prop.BindingName}Property;");
                    builder.Class.Private.WriteLine($"static void On{prop.BindingName}Changed({_winUINamespace}::Xaml::DependencyObject d, {_winUINamespace}::Xaml::DependencyPropertyChangedEventArgs e);");
                }
                else
                {
                    var exposedTypeName = QualifiedTypeName(prop.ExposedType);

                    var initialValue = prop.ExposedType switch
                    {
                        PropertySetValueType.Color => _s.ColorArgs((WinCompData.Wui.Color)prop.DefaultValue),
                        PropertySetValueType.Scalar => _s.Float((float)prop.DefaultValue),
                        PropertySetValueType.Vector2 => _s.Vector2Args((Vector2)prop.DefaultValue),
                        PropertySetValueType.Vector3 => _s.Vector3Args((Vector3)prop.DefaultValue),
                        PropertySetValueType.Vector4 => _s.Vector4Args((Vector4)prop.DefaultValue),
                        _ => throw new InvalidOperationException(),
                    };

                    WriteInitializedField(builder.Class.Private, exposedTypeName, $"_theme{prop.BindingName}", _s.VariableInitialization(initialValue));
                }
            }

            // EnsureThemeProperties is private. GetThemeProperties is the public version.
            builder.Class.Private.WriteLine($"winrt::{_wuc}::CompositionPropertySet EnsureThemeProperties(winrt::{_wuc}::Compositor compositor);");

            // Write properties declarations for each themed property.
            foreach (var prop in SourceInfo.SourceMetadata.PropertyBindings)
            {
                builder.Class.Public.WriteLine();
                builder.Class.Public.WriteLine($"{QualifiedTypeName(prop.ExposedType)} {prop.BindingName}();");
                builder.Class.Public.WriteLine($"void {prop.BindingName}({QualifiedTypeName(prop.ExposedType)} value);");
            }

            builder.Class.Public.WriteLine();
        }

        void WriteThemePropertyImpls(CodeBuilder builder)
        {
            var propertyBindings = SourceInfo.SourceMetadata.PropertyBindings;

            var sourceClassQualifier = $"{_sourceClassName}::";

            if (propertyBindings.Any(pb => pb.ExposedType == PropertySetValueType.Color))
            {
                // Write the helper for converting a color to a vector 4.
                builder.WriteLine($"float4 {sourceClassQualifier}ColorAsVector4(Color color)");
                builder.OpenScope();
                builder.WriteLine("return { static_cast<float>(color.R), static_cast<float>(color.G), static_cast<float>(color.B), static_cast<float>(color.A) };");
                builder.CloseScope();
                builder.WriteLine();
            }

            builder.WriteLine($"CompositionPropertySet {sourceClassQualifier}EnsureThemeProperties(Compositor compositor)");
            builder.OpenScope();
            builder.WriteLine($"if ({SourceInfo.ThemePropertiesFieldName} == nullptr)");
            builder.OpenScope();
            builder.WriteLine($"{SourceInfo.ThemePropertiesFieldName} = compositor.CreatePropertySet();");

            // Initialize the values in the property set.
            foreach (var prop in propertyBindings)
            {
                WriteThemePropertyInitialization(builder, SourceInfo.ThemePropertiesFieldName, prop);
            }

            builder.CloseScope();
            builder.WriteLine();
            builder.WriteLine($"return {SourceInfo.ThemePropertiesFieldName};");
            builder.CloseScope();
            builder.WriteLine();

            builder.WriteLine($"CompositionPropertySet {sourceClassQualifier}GetThemeProperties(Compositor compositor)");
            builder.OpenScope();
            builder.WriteLine("return EnsureThemeProperties(compositor);");
            builder.CloseScope();
            builder.WriteLine();

            // Write property implementations for each theme property.
            foreach (var prop in propertyBindings)
            {
                // Write the getter. This just reads the values out of the backing field.
                builder.WriteLine($"{TypeName(prop.ExposedType)} {sourceClassQualifier}{prop.BindingName}()");
                builder.OpenScope();
                builder.WriteLine($"return _theme{prop.BindingName};");
                builder.CloseScope();
                builder.WriteLine();

                // Write the setter. This saves to the backing field, and updates the theme property
                // set if one has been created.
                builder.WriteLine($"void {sourceClassQualifier}{prop.BindingName}({TypeName(prop.ExposedType)} value)");
                builder.OpenScope();
                builder.WriteLine($"_theme{prop.BindingName} = value;");
                builder.WriteLine("if (_themeProperties != nullptr)");
                builder.OpenScope();
                WriteThemePropertyInitialization(builder, "_themeProperties", prop);
                builder.CloseScope();
                builder.CloseScope();
                builder.WriteLine();
            }
        }

        void WriteIDynamicAnimatedVisualSourceHeaderText(HeaderBuilder builder)
        {
            var pub = builder.Class.Public;
            var priv = builder.Class.Private;

            priv.WriteLine($"const int c_loadedImageSurfaceCount = {SourceInfo.LoadedImageSurfaces.Distinct().Count()};");
            priv.WriteLine("double m_imageSuccessfulLoadingProgress{};");
            priv.WriteLine("int m_loadCompleteEventCount{};");
            priv.WriteLine("bool m_isAnimatedVisualSourceDynamic{};");
            priv.WriteLine("bool m_isImageLoadingCompleted{};");
            priv.WriteLine("bool m_isTryCreateAnimatedVisualCalled{};");
            priv.WriteLine("bool m_isImageLoadingStarted{};");
            priv.WriteLine("winrt::event<Windows::Foundation::TypedEventHandler<Microsoft::UI::Xaml::Controls::IDynamicAnimatedVisualSource, Windows::Foundation::IInspectable>> m_InternalHandler{};");
            priv.WriteLine("winrt::event<Windows::UI::Xaml::Data::PropertyChangedEventHandler> m_PropertyChanged{};");

            foreach (var n in SourceInfo.LoadedImageSurfaces)
            {
                priv.WriteLine($"winrt::Windows::UI::Xaml::Media::{n.TypeName} {n.FieldName}{{ nullptr }};");
            }

            priv.WriteLine("void EnsureImageLoadingStarted();");
            priv.WriteLine("void HandleLoadCompleted(winrt::Windows::UI::Xaml::Media::LoadedImageSurface sender, winrt::Windows::UI::Xaml::Media::LoadedImageSourceLoadCompletedEventArgs e);");

            // INotifyPropertyChanged implementation.
            pub.WriteLine("winrt::event_token PropertyChanged(Windows::UI::Xaml::Data::PropertyChangedEventHandler const& handler);");
            pub.WriteLine("void PropertyChanged(winrt::event_token const& token) noexcept;");

            // IDynamicAnimatedVisualSource implementation.
            pub.WriteLine();
            pub.WriteLine("winrt::event_token AnimatedVisualInvalidated(Windows::Foundation::TypedEventHandler<Microsoft::UI::Xaml::Controls::IDynamicAnimatedVisualSource, winrt::Windows::Foundation::IInspectable> const& handler);");
            pub.WriteLine("void AnimatedVisualInvalidated(winrt::event_token const& token) noexcept;");

            pub.WriteLine();
            pub.WriteSummaryComment("If this property is set to true, <see cref=\"TryCreateAnimatedVisual\"/> will" +
                " return null until all images have loaded. When all images have loaded, <see cref=\"TryCreateAnimatedVisual\"/>" +
                " will return the AnimatedVisual. To use, set it when declaring the AnimatedVisualSource. Once" +
                " <see cref=\"TryCreateAnimatedVisual\"/> is called, changes made to this property will be ignored." +
                " Default value is true.");
            pub.WriteLine("bool IsAnimatedVisualSourceDynamic();");
            pub.WriteLine("void IsAnimatedVisualSourceDynamic(bool value);");
            pub.WriteLine();

            pub.WriteSummaryComment("Returns true if all images have loaded. To see if the images succeeded to load," +
                " see <see cref=\"ImageSuccessfulLoadingProgress\"/>.");

            pub.WriteLine("bool IsImageLoadingCompleted();");
            pub.WriteLine();

            pub.WriteSummaryComment("Represents the progress of successful image loading. Returns a value between" +
                " 0 and 1. 0 means none of the images succeeded to load. 1 means all images succeeded to load.");

            pub.WriteLine("double ImageSuccessfulLoadingProgress();");
            pub.WriteLine();
            WriteTryCreateAnimatedVisualDeclaration(builder.Class.Public);
        }

        /// <inheritdoc/>
        protected override void WriteAnimatedVisualStart(
            CodeBuilder builder,
            IAnimatedVisualInfo info)
        {
            // Start writing the instantiator.
            builder.WriteLine($"class {info.ClassName} : public winrt::implements<{info.ClassName},");
            builder.Indent();
            builder.Indent();
            builder.WriteLine($"winrt::{_animatedVisualTypeName},");
            builder.WriteLine($"winrt::Windows::Foundation::IClosable>");
            builder.UnIndent();
            builder.UnIndent();
            builder.OpenScope();

            if (SourceInfo.UsesCanvasEffects ||
                SourceInfo.UsesCanvasGeometry)
            {
                // D2D factory field.
                builder.WriteLine("winrt::com_ptr<ID2D1Factory> _d2dFactory{ nullptr };");
            }
        }

        void AddUsingsForTypeAliases(CodeBuilder builder)
        {
            // Add usings for type aliases.
            if (SourceInfo.WinUi3)
            {
                builder.WriteLine($"using Color = winrt::Windows::UI::Color;");
                builder.WriteLine($"using CompositionPropertySet = winrt::Microsoft::UI::Composition::CompositionPropertySet;");
            }

            builder.WriteLine($"using TimeSpan = winrt::Windows::Foundation::TimeSpan;");
        }

        void WriteHeaderConstants(CodeBuilder builder)
        {
            // Add any internal constants. There is no "internal" in cppwinrt, so these
            // will become public.
            foreach (var c in SourceInfo.InternalConstants)
            {
                builder.WriteComment(c.Description);
                switch (c.Type)
                {
                    case ConstantType.Color:
                        builder.WriteLine($"static inline const winrt::Windows::UI::Color {c.Name}{_s.Color((WinCompData.Wui.Color)c.Value)};");
                        break;
                    case ConstantType.Int64:
                        builder.WriteLine($"static constexpr int64_t {c.Name}{{ {_s.Int64((long)c.Value)} }};");
                        break;
                    case ConstantType.Float:
                        builder.WriteLine($"static constexpr float {c.Name}{{ {_s.Float((float)c.Value)} }};");
                        break;
                    default:
                        throw new InvalidOperationException();
                }

                builder.WriteLine();
            }
        }

        /// <inheritdoc/>
        // Called by the base class to write the start of the cpp file (i.e. everything up to the body of the Instantiator class).
        protected override void WriteImplementationFileStart(CodeBuilder builder)
        {
            builder.WriteLine("#include \"pch.h\"");
            builder.WriteLine($"#include \"{_headerFileName}\"");
            builder.WriteLine($"#include \"{_fileBaseName}.g.cpp\"");

            // floatY, floatYxZ
            builder.WriteLine("#include <WindowsNumerics.h>");

            builder.WriteLine("#include <winrt/Windows.Foundation.Metadata.h>");

            if (SourceInfo.WinUi3)
            {
                builder.WriteLine("#include <winrt/Microsoft.UI.Composition.h>");
            }
            else
            {
                builder.WriteLine("#include <winrt/Windows.UI.Composition.h>");
            }

            if (_isIDynamic)
            {
                builder.WriteLine("#include <winrt/Windows.UI.Xaml.Media.h>");
            }

            if (SourceInfo.UsesCanvas ||
                SourceInfo.UsesCanvasEffects ||
                SourceInfo.UsesCanvasGeometry)
            {
                // D2D
                builder.WriteLine("#include \"d2d1.h\"");
                builder.WriteLine("#include <d2d1_1.h>");
                builder.WriteLine("#include <d2d1helper.h>");
                builder.WriteLine("#include <Windows.Graphics.Interop.h>");

                // Interop
                // BUILD_WINDOWS is defined if the code is being built as part of a Microsoft internal
                // Windows build. In that case the types in the Windows.Graphics.Effects.Interop.h file will
                // be in the Windows::Graphics::Effects namespace.
                //
                // Otherwise, the code is being built normally and the types will be in the
                // ::ABI::Windows::Graphics::Effects namespace.
                //
                // To work around this inconsistency, when BUILD_WINDOWS is defined, we wrap the include
                // of Windows.Graphics.Effects.Interop.h in the ABI namespace so that the types in that file
                // will always be in the ::ABI::Windows::Graphics::Effects namespace. And in our
                // generated code we always refer to the types in that file using the ABI:: prefix.
                builder.WriteLine("#ifdef BUILD_WINDOWS");
                builder.WriteLine("namespace ABI");
                builder.WriteLine("{");
                builder.WriteLine("#include <Windows.Graphics.Effects.Interop.h>");
                builder.WriteLine("}");
                builder.WriteLine("#else");
                builder.WriteLine("#include <Windows.Graphics.Effects.Interop.h>");
                builder.WriteLine("#endif");
                builder.WriteLine("#include <winrt/Windows.Graphics.Effects.h>");
            }

            if (SourceInfo.UsesStreams)
            {
                builder.WriteLine("#include <iostream>");
            }

            if (SourceInfo.UsesCompositeEffect)
            {
                // The CompsiteEffect class requires std::vector.
                builder.WriteLine("#include <vector>");
            }

            builder.WriteLine();

            var namespaces = new CppNamespaceListBuilder();

            namespaces.Add("winrt::Windows::Foundation::Numerics");
            namespaces.Add($"winrt::{_winUINamespace}");
            namespaces.Add($"winrt::{_wuc}");
            namespaces.Add("winrt::Windows::Graphics");

            if (SourceInfo.InterfaceType is null)
            {
                namespaces.Add(Muxc);
            }

            if (SourceInfo.UsesNamespaceWindowsUIXamlMedia)
            {
                namespaces.Add($"winrt::{_winUINamespace}::Xaml::Media");
            }

            if (SourceInfo.UsesStreams)
            {
                namespaces.Add("winrt::Platform");
                namespaces.Add("winrt::Windows::Storage::Streams");
            }

            if (SourceInfo.GenerateDependencyObject)
            {
                namespaces.Add($"{_winUINamespace}::Xaml");
            }

            builder.WriteCodeBuilder(namespaces.ToCodeBuilder());

            AddUsingsForTypeAliases(builder);

            builder.WriteLine();

            builder.WriteLine($"namespace winrt::{_s.Namespace(SourceInfo.Namespace)}::implementation");
            builder.OpenScope();

            if (SourceInfo.UsesCanvasEffects ||
                SourceInfo.UsesCanvasGeometry)
            {
                // Write CanvasGeometry to allow it's use in function definitions.
                builder.WriteLine(CanvasGeometryClass);
            }

            if (SourceInfo.UsesCompositeEffect)
            {
                // Write the composite effect class that will allow the use
                // of this effect without win2d.
                builder.WriteLine($"{CompositionEffectClass}");
            }
        }

        /// <inheritdoc/>
        protected override void WriteCanvasGeometryCombinationFactory(CodeBuilder builder, CanvasGeometry.Combination obj, string typeName, string fieldName)
        {
            builder.WriteLine("winrt::com_ptr<ID2D1Geometry>geoA{ nullptr };");
            builder.WriteLine("winrt::com_ptr<ID2D1Geometry>geoB{ nullptr };");
            builder.WriteLine($"{CallFactoryFor(obj.A)}->GetGeometry(geoA.put());");
            builder.WriteLine($"{CallFactoryFor(obj.B)}->GetGeometry(geoB.put());");
            builder.WriteLine("winrt::com_ptr<ID2D1PathGeometry> path;");
            builder.WriteLine("winrt::check_hresult(_d2dFactory->CreatePathGeometry(path.put()));");
            builder.WriteLine("winrt::com_ptr<ID2D1GeometrySink> sink{ nullptr };");
            builder.WriteLine("winrt::check_hresult(path->Open(sink.put()));");
            builder.WriteLine($"winrt::check_hresult(geoA->CombineWithGeometry(");
            builder.Indent();
            builder.WriteLine($"geoB.get(),");
            builder.WriteLine($"{_s.CanvasGeometryCombine(obj.CombineMode)},");
            builder.WriteLine($"{_s.Matrix3x2(obj.Matrix)},");
            builder.WriteLine($"sink.get()));");
            builder.UnIndent();
            builder.WriteLine("winrt::check_hresult(sink->Close());");
            builder.WriteLine($"auto result = {FieldAssignment(fieldName)}winrt::make_self<CanvasGeometry>(path);");
        }

        /// <inheritdoc/>
        protected override void WriteCanvasGeometryEllipseFactory(CodeBuilder builder, CanvasGeometry.Ellipse obj, string typeName, string fieldName)
        {
            builder.WriteLine("winrt::com_ptr<ID2D1EllipseGeometry> ellipse{ nullptr };");
            builder.WriteLine("winrt::check_hresult(_d2dFactory->CreateEllipseGeometry(");
            builder.Indent();
            builder.WriteLine($"D2D1::Ellipse({{{_s.Float(obj.X)},{_s.Float(obj.Y)}}}, {_s.Float(obj.RadiusX)}, {_s.Float(obj.RadiusY)}),");
            builder.WriteLine("ellipse.put()));");
            builder.UnIndent();
            builder.WriteLine($"auto result = {FieldAssignment(fieldName)}winrt::make_self<CanvasGeometry>(ellipse);");
        }

        /// <inheritdoc/>
        protected override void WriteCanvasGeometryRoundedRectangleFactory(CodeBuilder builder, CanvasGeometry.RoundedRectangle obj, string typeName, string fieldName)
        {
            builder.WriteLine("winrt::com_ptr<ID2D1RoundedRectangleGeometry> rect{ nullptr };");
            builder.WriteLine("winrt::check_hresult(_d2dFactory->CreateRoundedRectangleGeometry(");
            builder.Indent();
            builder.WriteLine($"D2D1::RoundedRect({{{_s.Float(obj.X)},{_s.Float(obj.Y)}}}, {_s.Float(obj.RadiusX)}, {_s.Float(obj.RadiusY)}),");
            builder.WriteLine("rect.put()));");
            builder.UnIndent();
            builder.WriteLine($"auto result = {FieldAssignment(fieldName)}winrt::make_self<CanvasGeometry>(rect);");
        }

        /// <inheritdoc/>
        protected override void WriteCanvasGeometryTransformedGeometryFactory(CodeBuilder builder, CanvasGeometry.TransformedGeometry obj, string typeName, string fieldName)
        {
            builder.WriteLine("winrt::com_ptr<ID2D1Geometry>geoA{ nullptr };");
            builder.WriteLine($"D2D1_MATRIX_3X2_F transformMatrix{_s.Matrix3x2(obj.TransformMatrix)};");
            builder.WriteLine($"{CallFactoryFor(obj.SourceGeometry)}->GetGeometry(geoA.put());");
            builder.WriteLine("winrt::com_ptr<ID2D1TransformedGeometry> transformed{ nullptr };");
            builder.WriteLine("winrt::check_hresult(_d2dFactory->CreateTransformedGeometry(geoA.get(), transformMatrix, transformed.put()));");
            builder.WriteLine($"auto result = {FieldAssignment(fieldName)}winrt::make_self<CanvasGeometry>(transformed);");
        }

        /// <inheritdoc/>
        protected override string WriteCompositeEffectFactory(CodeBuilder builder, Mgce.CompositeEffect compositeEffect)
        {
            builder.WriteLine("CompositeEffect compositeEffect{};");
            builder.WriteLine($"compositeEffect.SetMode({_s.CanvasCompositeMode(compositeEffect.Mode)});");
            foreach (var source in compositeEffect.Sources)
            {
                builder.WriteLine($"compositeEffect.AddSource(CompositionEffectSourceParameter(L\"{source.Name}\"));");
            }

            return "compositeEffect";
        }

        /// <inheritdoc/>
        // Called by the base class to write the end of the file (i.e. everything after the body of the AnimatedVisual class).
        protected override void WriteImplementationFileEnd(CodeBuilder builder)
        {
            builder.WriteLine();

            // Generate the methods that create and get the theme property set.
            if (SourceInfo.IsThemed)
            {
                WriteThemePropertyImpls(builder);
            }

            // Generate the method that creates an instance of the composition on the IAnimatedVisualSource.
            builder.WriteLine($"winrt::{_animatedVisualTypeName} {_sourceClassName}::TryCreateAnimatedVisual(");
            builder.Indent();
            builder.WriteLine("Compositor const& compositor,");
            builder.WriteLine("IInspectable& diagnostics)");

            builder.UnIndent();
            builder.OpenScope();

            if (SourceInfo.IsThemed)
            {
                builder.WriteLine("const auto _ = EnsureThemeProperties(compositor);");
            }

            if (_isIDynamic)
            {
                WriteIDynamicAnimatedVisualSource(builder);
            }
            else
            {
                WriteIAnimatedVisualSource(builder);
            }

            // Close the namespace.
            builder.UnIndent();
            builder.WriteLine("} // end namespace");
            builder.WriteLine();
        }

        /// <summary>
        /// Generate the body of the TryCreateAnimatedVisual() method for a composition that does not contain LoadedImageSurfaces.
        /// </summary>
        void WriteIAnimatedVisualSource(CodeBuilder builder)
        {
            builder.WriteLine("diagnostics = nullptr;");

            // Check the runtime version and instantiate the highest compatible IAnimatedVisual class.
            WriteInstantiateHighestCompatibleAnimatedVisual(builder, SourceInfo.AnimatedVisualInfos);

            builder.CloseScope();
        }

        void WriteInstantiateHighestCompatibleAnimatedVisual(
            CodeBuilder builder,
            IReadOnlyList<IAnimatedVisualInfo> animatedVisualInfos)
        {
            // WinUI3 doesn't ever do a version check. It's up to the user to make sure
            // the version they're using is compatible.
            if (SourceInfo.WinUi3)
            {
                var info = animatedVisualInfos.First();
                builder.WriteBreakableLine($"return winrt::make<{info.ClassName}>(", CommaSeparate(GetConstructorArguments(info)), ");");
            }
            else
            {
                foreach (var info in animatedVisualInfos.OrderByDescending(avi => avi.RequiredUapVersion))
                {
                    builder.WriteLine();
                    builder.WriteLine($"if ({info.ClassName}::IsRuntimeCompatible())");
                    builder.OpenScope();
                    builder.WriteBreakableLine($"return winrt::make<{info.ClassName}>(", CommaSeparate(GetConstructorArguments(info)), ");");
                    builder.CloseScope();
                }

                builder.WriteLine();
                builder.WriteLine("return nullptr;");
            }
        }

        /// <summary>
        /// Generate the body of the TryCreateAnimatedVisual() method for a composition that contains LoadedImageSurfaces.
        /// </summary>
        void WriteIDynamicAnimatedVisualSource(CodeBuilder builder)
        {
            builder.WriteLine("m_isTryCreateAnimatedVisualCalled = true;");
            builder.WriteLine("diagnostics = nullptr;");
            builder.WriteLine();

            // Check whether the runtime will support the lowest UAP version required.
            var animatedVisualInfos = SourceInfo.AnimatedVisualInfos.OrderByDescending(avi => avi.RequiredUapVersion).ToArray();

            // WinUI3 doesn't ever do a version check. It's up to the user to make sure
            // the version they're using is compatible.
            if (!SourceInfo.WinUi3)
            {
                builder.WriteLine($"if (!{animatedVisualInfos[animatedVisualInfos.Length - 1].ClassName}::IsRuntimeCompatible())");
                builder.OpenScope();
                builder.WriteLine("return nullptr;");
                builder.CloseScope();
            }

            builder.WriteLine();
            builder.WriteLine("EnsureImageLoadingStarted();");
            builder.WriteLine();
            builder.WriteLine("if (m_isAnimatedVisualSourceDynamic && m_loadCompleteEventCount != c_loadedImageSurfaceCount)");
            builder.OpenScope();
            builder.WriteLine("return nullptr;");
            builder.CloseScope();

            // Check the runtime version and instantiate the highest compatible IAnimatedVisual class.
            WriteInstantiateHighestCompatibleAnimatedVisual(builder, animatedVisualInfos);

            builder.CloseScope();
            builder.WriteLine();

            // Generate the get() and set() methods of IsAnimatedVisualSourceDynamic property.
            WriteSimplePropertyGetterImpl(builder, "IsAnimatedVisualSourceDynamic", "m_isAnimatedVisualSourceDynamic", "bool");
            builder.WriteLine($"void {_sourceClassName}::IsAnimatedVisualSourceDynamic(bool isAnimatedVisualSourceDynamic)");
            builder.OpenScope();
            builder.WriteLine("if (!m_isTryCreateAnimatedVisualCalled && m_isAnimatedVisualSourceDynamic != isAnimatedVisualSourceDynamic)");
            builder.OpenScope();
            builder.WriteLine("m_isAnimatedVisualSourceDynamic = isAnimatedVisualSourceDynamic;");
            builder.WriteLine($"m_PropertyChanged(*this, Windows::UI::Xaml::Data::PropertyChangedEventArgs(L\"IsAnimatedVisualSourceDynamic\"));");
            builder.CloseScope();
            builder.CloseScope();
            builder.WriteLine();

            // Generate the get() method of IsImageLoadingCompleted.
            WriteSimplePropertyGetterImpl(builder, "IsImageLoadingCompleted", "m_isImageLoadingCompleted", "bool");

            // Generate the get() method of ImageSuccessfulLoadingProgress
            WriteSimplePropertyGetterImpl(builder, "ImageSuccessfulLoadingProgress", "m_imageSuccessfulLoadingProgress", "double");

            // Generate the method that loads all the LoadedImageSurfaces.
            WriteEnsureImageLoadingStarted(builder);

            // Generate the method that handles the LoadCompleted event of the LoadedImageSurface objects.
            WriteHandleLoadCompleted(builder);

            // Generate the PropertyChanged event implementation.
            WriteEventImpl(
                builder,
                "PropertyChanged",
                "Windows::UI::Xaml::Data::PropertyChangedEventHandler",
                "m_PropertyChanged");

            // Generate the AnimatedVisualInvalidated event implementation.
            WriteEventImpl(
                builder,
                "AnimatedVisualInvalidated",
                "Windows::Foundation::TypedEventHandler<Microsoft::UI::Xaml::Controls::IDynamicAnimatedVisualSource, Windows::Foundation::IInspectable>",
                "m_InternalHandler");
        }

        void WriteEventImpl(CodeBuilder builder, string eventName, string handlerTypeName, string backingEventName)
        {
            builder.WriteLine($"winrt::event_token {_sourceClassName}::{eventName}({handlerTypeName} const& handler)");
            builder.OpenScope();
            builder.WriteLine($"return {backingEventName}.add(handler);");
            builder.CloseScope();
            builder.WriteLine();

            builder.WriteLine($"void {_sourceClassName}::{eventName}(winrt::event_token const& token) noexcept");
            builder.OpenScope();
            builder.WriteLine($"{backingEventName}.remove(token);");
            builder.CloseScope();
            builder.WriteLine();
        }

        void WriteSimplePropertyGetterImpl(CodeBuilder builder, string methodName, string backingFieldName, string typeName)
        {
            builder.WriteLine($"{typeName} {_sourceClassName}::{methodName}()");
            builder.OpenScope();
            builder.WriteLine($"return {backingFieldName};");
            builder.CloseScope();
            builder.WriteLine();
        }

        void WriteEnsureImageLoadingStarted(CodeBuilder builder)
        {
            builder.WriteLine($"void {_sourceClassName}::EnsureImageLoadingStarted()");
            builder.OpenScope();
            builder.WriteLine("if (!m_isImageLoadingStarted)");
            builder.OpenScope();
            builder.WriteLine($"auto eventHandler = Windows::Foundation::TypedEventHandler<LoadedImageSurface, LoadedImageSourceLoadCompletedEventArgs>(this, &{_sourceClassName}::HandleLoadCompleted);");

            foreach (var n in SourceInfo.LoadedImageSurfaces)
            {
                var imageMemberName = n.FieldName;
                switch (n.LoadedImageSurfaceType)
                {
                    case LoadedImageSurface.LoadedImageSurfaceType.FromStream:
                        var streamName = $"stream_{n.Name}";
                        var dataWriterName = $"dataWriter_{n.Name}";
                        builder.WriteLine($"auto {streamName} = ref new InMemoryRandomAccessStream();");
                        builder.WriteLine($"auto {dataWriterName} = ref new DataWriter({streamName}->GetOutputStreamAt(0));");
                        builder.WriteLine($"{dataWriterName}->WriteBytes({n.BytesFieldName});");
                        builder.WriteLine($"{dataWriterName}->StoreAsync();");
                        builder.WriteLine($"{dataWriterName}->FlushAsync();");
                        builder.WriteLine($"{streamName}->Seek(0);");
                        builder.WriteLine($"{imageMemberName} = {_winUINamespace}::Xaml::Media::LoadedImageSurface::StartLoadFromStream({streamName});");
                        break;
                    case LoadedImageSurface.LoadedImageSurfaceType.FromUri:
                        builder.WriteLine($"{imageMemberName} = {_winUINamespace}::Xaml::Media::LoadedImageSurface::StartLoadFromUri(Windows::Foundation::Uri(L\"{n.ImageUri.AbsoluteUri}\"));");
                        break;
                    default:
                        throw new InvalidOperationException();
                }

                builder.WriteLine($"{imageMemberName}.LoadCompleted(eventHandler);");
            }

            builder.WriteLine("m_isImageLoadingStarted = true;");
            builder.CloseScope();
            builder.CloseScope();
            builder.WriteLine();
        }

        void WriteHandleLoadCompleted(CodeBuilder builder)
        {
            builder.WriteLine($"void {_sourceClassName}::HandleLoadCompleted(LoadedImageSurface sender, LoadedImageSourceLoadCompletedEventArgs e)");
            builder.OpenScope();
            builder.WriteLine("m_loadCompleteEventCount++;");
            builder.WriteLine("if (e.Status() == LoadedImageSourceLoadStatus::Success)");
            builder.OpenScope();
            builder.WriteLine("m_imageSuccessfulLoadingProgress = (double)m_loadCompleteEventCount / c_loadedImageSurfaceCount;");
            builder.WriteLine("m_PropertyChanged(*this, Windows::UI::Xaml::Data::PropertyChangedEventArgs(L\"ImageSuccessfulLoadingProgress\"));");
            builder.CloseScope();
            builder.WriteLine();
            builder.WriteLine("if (m_loadCompleteEventCount == c_loadedImageSurfaceCount)");
            builder.OpenScope();
            builder.WriteLine("m_isImageLoadingCompleted = true;");
            builder.WriteLine("m_PropertyChanged(*this, Windows::UI::Xaml::Data::PropertyChangedEventArgs(L\"IsImageLoadingCompleted\"));");
            builder.WriteLine("if (m_isAnimatedVisualSourceDynamic)");
            builder.OpenScope();
            builder.WriteLine("m_InternalHandler(*this, nullptr);");
            builder.CloseScope();
            builder.CloseScope();
            builder.CloseScope();
            builder.WriteLine();
        }

        void WriteIsRuntimeCompatibleMethod(CodeBuilder builder, IAnimatedVisualInfo info)
        {
            // WinUI3 doesn't ever do a version check. It's up to the user to make sure
            // the version they're using is compatible.
            if (!SourceInfo.WinUi3)
            {
                // Write the IsRuntimeCompatible static method.
                builder.WriteLine("static bool IsRuntimeCompatible()");
                builder.OpenScope();
                builder.WriteLine($"return winrt::Windows::Foundation::Metadata::ApiInformation::IsApiContractPresent(L\"Windows.Foundation.UniversalApiContract\", {info.RequiredUapVersion});");
                builder.CloseScope();
            }
        }

        /// <inheritdoc/>
        // Called by the base class to write the end of the AnimatedVisual class.
        protected override void WriteAnimatedVisualEnd(
            CodeBuilder builder,
            IAnimatedVisualInfo info)
        {
            if (SourceInfo.UsesCanvasEffects ||
                SourceInfo.UsesCanvasGeometry)
            {
                // Utility method for D2D geometries.
                builder.WriteLine("static winrt::Windows::Graphics::IGeometrySource2D CanvasGeometryToIGeometrySource2D(winrt::com_ptr<CanvasGeometry> geo)");
                builder.OpenScope();
                builder.WriteLine("return geo.as<winrt::Windows::Graphics::IGeometrySource2D>();");
                builder.CloseScope();
                builder.WriteLine();
            }

            // Write the constructor for the AnimatedVisual class.
            builder.UnIndent();
            builder.WriteLine("public:");
            builder.Indent();

            // Constructor.
            builder.WriteBreakableLine($"{info.ClassName}(", CommaSeparate(GetConstructorParameters(info)), ")");
            builder.Indent();

            // Initializer list.
            builder.WriteLine(": _c{compositor}");
            if (SourceInfo.IsThemed)
            {
                builder.WriteLine($", {SourceInfo.ThemePropertiesFieldName}{{themeProperties}}");
            }

            // Initialize the image surfaces.
            foreach (var n in info.LoadedImageSurfaceNodes)
            {
                builder.WriteLine($", {n.FieldName}({_s.CamelCase(n.Name)})");
            }

            // Instantiate the reusable ExpressionAnimation.
            builder.WriteLine($", {SourceInfo.ReusableExpressionAnimationFieldName}(compositor.CreateExpressionAnimation())");

            builder.UnIndent();

            builder.OpenScope();
            if (SourceInfo.UsesCanvasEffects ||
                SourceInfo.UsesCanvasGeometry)
            {
                builder.WriteLine("winrt::check_hresult(D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, _d2dFactory.put()));");
            }

            // Instantiate the root. This will cause the whole Visual tree to be built and animations started.
            builder.WriteLine("const auto _ = Root();");
            builder.CloseScope();

            builder.WriteLine();
            builder.WriteLine("void Close()");
            builder.OpenScope();
            builder.WriteLine("if (_root)");
            builder.OpenScope();
            builder.WriteLine("_root.Close();");
            builder.CloseScope();
            builder.CloseScope();

            // Write the members on IAnimatedVisual.
            builder.WriteLine();
            {
                var propertyImplBuilder = new CodeBuilder();
                propertyImplBuilder.WriteLine($"return {{ {_s.TimeSpan(SourceInfo.DurationTicksFieldName)} }};");
                WritePropertyImpl(builder, "TimeSpan", "Duration", propertyImplBuilder);
            }

            builder.WriteLine();
            {
                var propertyImplBuilder = new CodeBuilder();
                propertyImplBuilder.WriteLine("return _root;");
                WritePropertyImpl(builder, nameof(Visual), "RootVisual", propertyImplBuilder);
            }

            builder.WriteLine();
            {
                var propertyImplBuilder = new CodeBuilder();
                propertyImplBuilder.WriteLine($"return {_s.Vector2(SourceInfo.CompositionDeclaredSize)};");
                WritePropertyImpl(builder, "float2", "Size", propertyImplBuilder);
            }

            WriteIsRuntimeCompatibleMethod(builder, info);

            // Close the scope for the instantiator class.
            builder.CloseCppTypeScope();
        }

        void WritePropertyImpl(
            CodeBuilder builder,
            string returnType,
            string propertyName,
            CodeBuilder getImplementation)
        {
            builder.WriteLine($"{returnType} {propertyName}() const");
            builder.OpenScope();
            builder.WriteCodeBuilder(getImplementation);
            builder.CloseScope();
            builder.WriteLine();
        }

        /// <inheritdoc/>
        protected override void WriteCanvasGeometryPathFactory(CodeBuilder builder, CanvasGeometry.Path obj, string typeName, string fieldName)
        {
            // D2D Setup
            builder.WriteLine("winrt::com_ptr<ID2D1PathGeometry> path{ nullptr };");
            builder.WriteLine("winrt::check_hresult(_d2dFactory->CreatePathGeometry(path.put()));");
            builder.WriteLine("winrt::com_ptr<ID2D1GeometrySink> sink{ nullptr };");
            builder.WriteLine("winrt::check_hresult(path->Open(sink.put()));");

            if (obj.FilledRegionDetermination != CanvasFilledRegionDetermination.Alternate)
            {
                builder.WriteLine($"sink->SetFillMode({_s.FilledRegionDetermination(obj.FilledRegionDetermination)});");
            }

            foreach (var command in obj.Commands)
            {
                switch (command.Type)
                {
                    case CanvasPathBuilder.CommandType.BeginFigure:
                        // Assume D2D1_FIGURE_BEGIN_FILLED
                        builder.WriteLine($"sink->BeginFigure({_s.Vector2(((CanvasPathBuilder.Command.BeginFigure)command).StartPoint)}, D2D1_FIGURE_BEGIN_FILLED);");
                        break;
                    case CanvasPathBuilder.CommandType.EndFigure:
                        builder.WriteLine($"sink->EndFigure({_s.CanvasFigureLoop(((CanvasPathBuilder.Command.EndFigure)command).FigureLoop)});");
                        break;
                    case CanvasPathBuilder.CommandType.AddLine:
                        builder.WriteLine($"sink->AddLine({_s.Vector2(((CanvasPathBuilder.Command.AddLine)command).EndPoint)});");
                        break;
                    case CanvasPathBuilder.CommandType.AddCubicBezier:
                        var cb = (CanvasPathBuilder.Command.AddCubicBezier)command;
                        builder.WriteLine($"sink->AddBezier({{ {_s.Vector2(cb.ControlPoint1)}, {_s.Vector2(cb.ControlPoint2)}, {_s.Vector2(cb.EndPoint)} }});");
                        break;
                    default:
                        throw new InvalidOperationException();
                }
            }

            builder.WriteLine("winrt::check_hresult(sink->Close());");
            builder.WriteLine($"auto result = {FieldAssignment(fieldName)}winrt::make_self<CanvasGeometry>(path);");
        }

        /// <inheritdoc/>
        protected override void WriteCanvasGeometryGroupFactory(CodeBuilder builder, CanvasGeometry.Group obj, string typeName, string fieldName)
        {
            builder.WriteLine($"winrt::com_ptr<ID2D1Geometry> geometries[{obj.Geometries.Length}]");
            builder.OpenScope();
            for (var i = 0; i < obj.Geometries.Length; i++)
            {
                var geometry = obj.Geometries[i];
                builder.WriteLine($"{CallFactoryFor(geometry)}.get()->Geometry(),");
            }

            builder.CloseCppTypeScope();
            builder.WriteLine("winrt::com_ptr<ID2D1GeometryGroup> group{ nullptr };");
            builder.WriteLine("winrt::check_hresult(_d2dFactory->CreateGeometryGroup(");
            builder.Indent();
            builder.WriteLine($"{_s.FilledRegionDetermination(obj.FilledRegionDetermination)},");
            builder.WriteLine("(ID2D1Geometry**)(&geometries),");
            builder.WriteLine($"{obj.Geometries.Length},");
            builder.WriteLine("group.put()));");
            builder.UnIndent();
            builder.WriteLine($"auto result = {FieldAssignment(fieldName)}winrt::make_self<CanvasGeometry>(group);");
        }

        string QualifiedTypeName(PropertySetValueType propertySetValueType)
            => propertySetValueType switch
            {
                PropertySetValueType.Color => $"winrt::Windows::UI::Color",
                _ => TypeName(propertySetValueType),
            };

        IEnumerable<string> GetConstructorParameters(IAnimatedVisualInfo info)
        {
            yield return "Compositor compositor";

            if (SourceInfo.IsThemed)
            {
                yield return "CompositionPropertySet themeProperties";
            }

            foreach (var loadedImageSurfaceNode in info.LoadedImageSurfaceNodes)
            {
                yield return $"{loadedImageSurfaceNode.TypeName} {_s.CamelCase(loadedImageSurfaceNode.Name)}";
            }
        }

        sealed class ClassBuilder
        {
            internal CodeBuilder Preamble { get; } = new CodeBuilder();

            internal CodeBuilder Private { get; } = new CodeBuilder();

            internal CodeBuilder Public { get; } = new CodeBuilder();

            internal CodeBuilder ToCodeBuilder()
            {
                var result = new CodeBuilder();
                result.WriteCodeBuilder(Preamble);
                result.Indent();
                result.WriteCodeBuilder(Private);
                result.UnIndent();
                result.WriteLine("public:");
                result.Indent();
                result.WriteCodeBuilder(Public);
                result.CloseCppTypeScope();
                return result;
            }

            public override string ToString() => ToCodeBuilder().ToString();
        }

        sealed class HeaderBuilder
        {
            // Everything up to and including the opening of the namespace
            internal CodeBuilder Preamble { get; } = new CodeBuilder();

            internal ClassBuilder Class { get; } = new ClassBuilder();

            internal CodeBuilder Postamble { get; } = new CodeBuilder();

            internal CodeBuilder ToCodeBuilder()
            {
                var result = new CodeBuilder();
                result.WriteCodeBuilder(Preamble);
                result.Indent();
                result.Indent();
                result.WriteCodeBuilder(Class.ToCodeBuilder());
                result.UnIndent();
                result.WriteCodeBuilder(Postamble);
                result.CloseScope();
                return result;
            }

            public override string ToString() => ToCodeBuilder().ToString();
        }

        static string CanvasGeometryClass =>
@"class CanvasGeometry : public winrt::implements<CanvasGeometry,
        winrt::Windows::Graphics::IGeometrySource2D,
        ::ABI::Windows::Graphics::IGeometrySource2DInterop>
    {
        winrt::com_ptr<ID2D1Geometry> _geometry{ nullptr };

    public:
        CanvasGeometry(winrt::com_ptr<ID2D1Geometry> geometry)
            : _geometry{ geometry }
        { }

        // IGeometrySource2D.
        winrt::com_ptr<ID2D1Geometry> Geometry() { return _geometry; }

        // IGeometrySource2DInterop.
        IFACEMETHODIMP GetGeometry(ID2D1Geometry** value) override
        {
            _geometry.copy_to(value);
            return S_OK;
        }

        // IGeometrySource2DInterop.
        IFACEMETHODIMP TryGetGeometryUsingFactory(ID2D1Factory*, ID2D1Geometry**) override
        {
            return E_NOTIMPL;
        }
    };
";

        static string CompositionEffectClass =>
@"
    enum class CanvasComposite : int
    {
        SourceOver = 0,
        DestinationOver = 1,
        SourceIn = 2,
        DestinationIn = 3,
        SourceOut = 4,
        DestinationOut = 5,
        SourceAtop = 6,
        DestinationAtop = 7,
        Xor = 8,
        Add = 9,
        Copy = 10,
        BoundedCopy = 11,
        MaskInvert = 12,
    };

    // This class is a substitute for the Microsoft::Graphics::Canvas::Effects::CompositeEffect
    // class so that composite effects can be used with 
    // Windows::UI::Composition::CompositionEffectBrush without requiring Win2d. This is
    // achieved by implementing the interfaces Windows::UI::Composition requires for it
    // to consume an effect.
    class CompositeEffect : public winrt::implements<CompositeEffect,
        winrt::Windows::Graphics::Effects::IGraphicsEffect,
        winrt::Windows::Graphics::Effects::IGraphicsEffectSource,
        ::ABI::Windows::Graphics::Effects::IGraphicsEffectD2D1Interop>
    {
        winrt::hstring m_name{};
        CanvasComposite m_mode{};
        std::vector<winrt::Windows::Graphics::Effects::IGraphicsEffectSource> m_sources{};

    public:
        void SetMode(CanvasComposite mode) { m_mode = mode; }

        void AddSource(winrt::Windows::Graphics::Effects::IGraphicsEffectSource source)
        {
            m_sources.emplace_back(source);
        }

        // IGraphicsEffect.
        void Name(winrt::hstring name) { m_name = name; }
        winrt::hstring Name() { return m_name; }

        // IGraphicsEffectD2D1Interop.
        IFACEMETHODIMP GetEffectId(GUID* id) override
        {
            if (id != nullptr)
            {
                // set CLSID_D2D1Composite value
                *id = { 0x48fc9f51, 0xf6ac, 0x48f1, { 0x8b, 0x58,  0x3b,  0x28,  0xac,  0x46,  0xf7,  0x6d } };
            }

            return S_OK;
        }

        IFACEMETHODIMP GetSourceCount(UINT* count) override
        {
            if (count != nullptr)
            {
                *count = static_cast<UINT>(m_sources.size());
            }

            return S_OK;
        }

        IFACEMETHODIMP GetSource(
            UINT index,
            ::ABI::Windows::Graphics::Effects::IGraphicsEffectSource** source) override
        {
            if (index >= m_sources.size() ||
                source == nullptr)
            {
                return E_INVALIDARG;
            }

            m_sources.at(index).as<::ABI::Windows::Graphics::Effects::IGraphicsEffectSource>().copy_to(source);

            return S_OK;
        }

        IFACEMETHODIMP GetPropertyCount(UINT* count) override { *count = 1; return S_OK; }

        IFACEMETHODIMP GetProperty(
            UINT index,
            ::ABI::Windows::Foundation::IPropertyValue** value) override
        {
            switch (index)
            {
            case D2D1_COMPOSITE_PROP_MODE:
                winrt::Windows::Foundation::PropertyValue::CreateUInt32(
                    static_cast<uint32_t>(m_mode)).as<::ABI::Windows::Foundation::IPropertyValue>().copy_to(value);
                return S_OK;
            default:
                *value = nullptr;
                return E_INVALIDARG;
            }
        }

        IFACEMETHODIMP GetNamedPropertyMapping(
            LPCWSTR,
            UINT*,
            ::ABI::Windows::Graphics::Effects::GRAPHICS_EFFECT_PROPERTY_MAPPING*) override
        {
            return E_INVALIDARG;
        }
    };
";
    }
}
