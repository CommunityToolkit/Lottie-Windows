// Copyright(c) Microsoft Corporation.All rights reserved.
// Licensed under the MIT License.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Numerics;
using System.Text;
using Microsoft.Toolkit.Uwp.UI.Lottie.GenericData;
using Microsoft.Toolkit.Uwp.UI.Lottie.UIData.Tools;
using Microsoft.Toolkit.Uwp.UI.Lottie.WinCompData;
using Microsoft.Toolkit.Uwp.UI.Lottie.WinCompData.Mgcg;
using Microsoft.Toolkit.Uwp.UI.Lottie.WinCompData.Wui;
using Mgce = Microsoft.Toolkit.Uwp.UI.Lottie.WinCompData.Mgce;
using Wg = Microsoft.Toolkit.Uwp.UI.Lottie.WinCompData.Wg;
using Wmd = Microsoft.Toolkit.Uwp.UI.Lottie.WinUIXamlMediaData;

namespace Microsoft.Toolkit.Uwp.UI.Lottie.UIData.CodeGen
{
#if PUBLIC_UIDataCodeGen
    public
#endif
    abstract class InstantiatorGeneratorBase : IAnimatedVisualSourceInfo
    {
        // The name of the field holding the singleton reusable ExpressionAnimation.
        const string SingletonExpressionAnimationName = "_reusableExpressionAnimation";

        // The name of the constant holding the duration of the animation in ticks.
        const string DurationTicksFieldName = "c_durationTicks";
        static readonly string[] _autoGeneratedHeaderText = new string[]
        {
            "//------------------------------------------------------------------------------",
            "// <auto-generated>",
            "//     This code was generated by a tool.",
            "//",
            "//     Changes to this file may cause incorrect behavior and will be lost if",
            "//     the code is regenerated.",
            "// </auto-generated>",
            "//------------------------------------------------------------------------------",
        };

        // The name of the IAnimatedVisualSource class.
        readonly string _className;
        readonly Vector2 _compositionDeclaredSize;
        readonly TimeSpan _compositionDuration;
        readonly bool _setCommentProperties;
        readonly bool _disableFieldOptimization;
        readonly Stringifier _stringifier;
        readonly IReadOnlyList<AnimatedVisualGenerator> _animatedVisualGenerators;
        readonly LoadedImageSurfaceInfo[] _loadedImageSurfaceInfos;
        readonly Dictionary<ObjectData, LoadedImageSurfaceInfo> _loadedImageSurfaceInfosByNode;
        readonly GenericDataMap _sourceMetadata;
        AnimatedVisualGenerator _currentAnimatedVisualGenerator;

        protected InstantiatorGeneratorBase(
            string className,
            Vector2 compositionDeclaredSize,
            IReadOnlyList<(CompositionObject graphRoot, uint requiredUapVersion)> graphs,
            GenericDataMap sourceMetadata,
            TimeSpan duration,
            bool setCommentProperties,
            bool disableFieldOptimization,
            Stringifier stringifier)
        {
            _className = className;
            _compositionDeclaredSize = compositionDeclaredSize;
            _sourceMetadata = sourceMetadata;
            _compositionDuration = duration;
            _setCommentProperties = setCommentProperties;
            _disableFieldOptimization = disableFieldOptimization;
            _stringifier = stringifier;

            _animatedVisualGenerators = graphs.Select(g => new AnimatedVisualGenerator(this, className, g.graphRoot, g.requiredUapVersion)).ToArray();

            // Deal with the nodes that are shared between multiple AnimatedVisual classes.
            // The nodes need naming, and some other adjustments.
            var shareableNodes = _animatedVisualGenerators.SelectMany(a => a.GetShareableNodes()).ToArray();

            // Ensure that we only have to deal with LoadedImageSurface nodes as they are the only
            // nodes that we currently need to share. This can be removed if we need to share
            // other types of nodes later. Asserting that we only have LoadedImageSurface nodes
            // here makes the code following this simpler.
            if (shareableNodes.Where(n => !n.IsLoadedImageSurface).Any())
            {
                throw new InvalidOperationException();
            }

            var sharedNodeGroups =
                (from n in shareableNodes
                 let obj = (Wmd.LoadedImageSurface)n.Object
                 let key = obj.Type == Wmd.LoadedImageSurface.LoadedImageSurfaceType.FromUri
                             ? (object)((Wmd.LoadedImageSurfaceFromUri)obj).Uri
                             : ((Wmd.LoadedImageSurfaceFromStream)obj).Bytes
                 group n by key into g
                 select new SharedNodeGroup(g)).ToArray();

            // Generate names for each of the canonical nodes (i.e. the first node in each group).
            foreach ((var n, var name) in NodeNamer<ObjectData>.GenerateNodeNames(sharedNodeGroups.Select(g => g.CanonicalNode)))
            {
                n.Name = name;
            }

            // Apply the name from the canonical node to the other nodes in its group so they will be
            // treated during generation as if they are the same object.
            foreach (var sharedNodeGroup in sharedNodeGroups)
            {
                var canonicalNode = sharedNodeGroup.CanonicalNode;
                if (canonicalNode.UsesAssetFile)
                {
                    // Set the Uri of the image file for LoadedImageSurfaceFromUri to $"ms-appx:///Assets/<className>/<filePath>/<fileName>.
                    var loadedImageSurfaceObj = (Wmd.LoadedImageSurfaceFromUri)canonicalNode.Object;
                    var imageUri = loadedImageSurfaceObj.Uri;

                    if (imageUri.IsFile)
                    {
                        canonicalNode.LoadedImageSurfaceImageUri = new Uri($"ms-appx:///Assets/{className}{imageUri.AbsolutePath}");
                    }
                }

                // Propagate the name and Uri to the other nodes in the group.
                foreach (var n in sharedNodeGroup.Rest)
                {
                    n.Name = canonicalNode.Name;
                    n.LoadedImageSurfaceImageUri = canonicalNode.LoadedImageSurfaceImageUri;
                }
            }

            var sharedLoadedImageSurfaceInfos = (from g in sharedNodeGroups
                                                 let loadedImageSurfaceNode = LoadedImageSurfaceInfoFromObjectData(g.CanonicalNode)
                                                 from node in OrderByName(g.All)
                                                 select (node, loadedImageSurfaceNode)).ToArray();

            _loadedImageSurfaceInfos = sharedLoadedImageSurfaceInfos.
                                            Select(n => n.loadedImageSurfaceNode).
                                            Distinct().
                                            OrderBy(lisi => lisi.Name, AlphanumericStringComparer.Instance).
                                            ToArray();

            _loadedImageSurfaceInfosByNode = sharedLoadedImageSurfaceInfos.ToDictionary(n => n.node, n => n.loadedImageSurfaceNode);
        }

        /// <summary>
        /// Takes a name and modifies it as necessary to be suited for use as a class name in languages such
        /// as  C# and C++.
        /// Returns null on failure.
        /// </summary>
        /// <returns>A name, or null.</returns>
        public static string TrySynthesizeClassName(string name)
        {
            if (string.IsNullOrWhiteSpace(name))
            {
                return null;
            }

            // Remove any non-characters from the start of the name.
            var nonCharPrefixSize = name.TakeWhile(c => !char.IsLetter(c)).Count();
            return SanitizeTypeName(name.Substring(nonCharPrefixSize));
        }

        /// <summary>
        /// Gets the standard header text used to indicate that a file contains auto-generated content.
        /// </summary>
        protected static IReadOnlyList<string> AutoGeneratedHeaderText => _autoGeneratedHeaderText;

        /// <summary>
        /// Writes the start of the file, e.g. using namespace statements and includes at the top of the file.
        /// </summary>
        protected abstract void WriteFileStart(
            CodeBuilder builder,
            IAnimatedVisualSourceInfo info);

        /// <summary>
        /// Writes the start of the IAnimatedVisual implementation class.
        /// </summary>
        protected abstract void WriteAnimatedVisualStart(
            CodeBuilder builder,
            IAnimatedVisualInfo info);

        /// <summary>
        /// Writes the end of the IAnimatedVisual implementation class.
        /// </summary>
        protected abstract void WriteAnimatedVisualEnd(
            CodeBuilder builder,
            IAnimatedVisualInfo info);

        /// <summary>
        /// Writes the end of the file.
        /// </summary>
        protected abstract void WriteFileEnd(
            CodeBuilder builder,
            IAnimatedVisualSourceInfo info);

        /// <summary>
        /// Writes CanvasGeometery.Combination factory code.
        /// </summary>
        /// <param name="builder">A <see cref="CodeBuilder"/> used to create the code.</param>
        /// <param name="obj">Describes the object that should be instantiated by the factory code.</param>
        /// <param name="typeName">The type of the result.</param>
        /// <param name="fieldName">If not null, the name of the field in which the result is stored.</param>
        protected abstract void WriteCanvasGeometryCombinationFactory(
            CodeBuilder builder,
            CanvasGeometry.Combination obj,
            string typeName,
            string fieldName);

        /// <summary>
        /// Writes CanvasGeometery.Ellipse factory code.
        /// </summary>
        /// <param name="builder">A <see cref="CodeBuilder"/> used to create the code.</param>
        /// <param name="obj">Describes the object that should be instantiated by the factory code.</param>
        /// <param name="typeName">The type of the result.</param>
        /// <param name="fieldName">If not null, the name of the field in which the result is stored.</param>
        protected abstract void WriteCanvasGeometryEllipseFactory(
            CodeBuilder builder,
            CanvasGeometry.Ellipse obj,
            string typeName,
            string fieldName);

        /// <summary>
        /// Writes CanvasGeometery.Ellipse factory code.
        /// </summary>
        /// <param name="builder">A <see cref="CodeBuilder"/> used to create the code.</param>
        /// <param name="obj">Describes the object that should be instantiated by the factory code.</param>
        /// <param name="typeName">The type of the result.</param>
        /// <param name="fieldName">If not null, the name of the field in which the result is stored.</param>
        protected abstract void WriteCanvasGeometryGroupFactory(
            CodeBuilder builder,
            CanvasGeometry.Group obj,
            string typeName,
            string fieldName);

        /// <summary>
        /// Writes CanvasGeometery.Path factory code.
        /// </summary>
        /// <param name="builder">A <see cref="CodeBuilder"/> used to create the code.</param>
        /// <param name="obj">Describes the object that should be instantiated by the factory code.</param>
        /// <param name="typeName">The type of the result.</param>
        /// <param name="fieldName">If not null, the name of the field in which the result is stored.</param>
        protected abstract void WriteCanvasGeometryPathFactory(
            CodeBuilder builder,
            CanvasGeometry.Path obj,
            string typeName,
            string fieldName);

        /// <summary>
        /// Writes CanvasGeometery.RoundedRectangle factory code.
        /// </summary>
        /// <param name="builder">A <see cref="CodeBuilder"/> used to create the code.</param>
        /// <param name="obj">Describes the object that should be instantiated by the factory code.</param>
        /// <param name="typeName">The type of the result.</param>
        /// <param name="fieldName">If not null, the name of the field in which the result is stored.</param>
        protected abstract void WriteCanvasGeometryRoundedRectangleFactory(
            CodeBuilder builder,
            CanvasGeometry.RoundedRectangle obj,
            string typeName,
            string fieldName);

        /// <summary>
        /// Writes CanvasGeometery.TransformedGeometry factory code.
        /// </summary>
        /// <param name="builder">A <see cref="CodeBuilder"/> used to create the code.</param>
        /// <param name="obj">Describes the object that should be instantiated by the factory code.</param>
        /// <param name="typeName">The type of the result.</param>
        /// <param name="fieldName">If not null, the name of the field in which the result is stored.</param>
        protected abstract void WriteCanvasGeometryTransformedGeometryFactory(
            CodeBuilder builder,
            CanvasGeometry.TransformedGeometry obj,
            string typeName,
            string fieldName);

        /// <summary>
        /// Write the CompositeEffect factory code.
        /// </summary>
        /// <param name="builder">A <see cref="CodeBuilder"/> used to create the code.</param>
        /// <param name="compositeEffect">Composite effect object.</param>
        /// <returns>String that should be used as the parameter for CreateEffectFactory.</returns>
        protected abstract string WriteCompositeEffectFactory(
            CodeBuilder builder,
            Mgce.CompositeEffect compositeEffect);

        /// <summary>
        /// Write a Bytes field.
        /// </summary>
        /// <param name="builder">A <see cref="CodeBuilder"/> used to create the code.</param>
        /// <param name="fieldName">The name of the Bytes field to be written.</param>
        protected void WriteBytesField(CodeBuilder builder, string fieldName)
        {
            builder.WriteLine($"{_stringifier.Static} {_stringifier.Readonly(_stringifier.ReferenceTypeName(_stringifier.ByteArray))} {fieldName} = {_stringifier.New} {_stringifier.ByteArray}");
        }

        /// <summary>
        /// Call this to get a list of the asset files referenced by the generated code.
        /// </summary>
        /// <returns>
        /// List of asset files and their relative path to the Asset folder in a UWP that are referenced by the generated code.
        /// An item in the returned list has format "ms-appx:///Assets/subFolder/fileName", which the generated code
        /// will use to load the file from.
        /// </returns>
        protected IReadOnlyList<Uri> GetAssetsList() => _loadedImageSurfaceInfos.Where(n => n.ImageUri != null).Select(n => n.ImageUri).ToArray();

        /// <summary>
        /// Call this to generate the code. Returns a string containing the generated code.
        /// </summary>
        /// <returns>The code.</returns>
        protected string GenerateCode()
        {
            var builder = new CodeBuilder();

            // Write the auto-generated warning comment.
            foreach (var line in AutoGeneratedHeaderText)
            {
                builder.WriteLine(line);
            }

            // Write the start of the file. This is everything up to the start of the AnimatedVisual class.
            WriteFileStart(builder, this);

            // Write the LoadedImageSurface byte arrays into the outer (IAnimatedVisualSource) class.
            WriteLoadedImageSurfaceArrays(builder);

            // Write each AnimatedVisual class.
            var firstAnimatedVisualWritten = false;
            foreach (var animatedVisualGenerator in _animatedVisualGenerators)
            {
                if (firstAnimatedVisualWritten)
                {
                    // Put a blank line between each AnimatedVisual class.
                    builder.WriteLine();
                }

                animatedVisualGenerator.WriteAnimatedVisualCode(builder);
                firstAnimatedVisualWritten = true;
            }

            // Write the end of the file.
            WriteFileEnd(builder, this);

            return builder.ToString();
        }

        /// <summary>
        /// Returns the code to call the factory for the given object.
        /// </summary>
        /// <returns>The code to call the factory for the given object.</returns>
        protected string CallFactoryFor(CanvasGeometry obj) => _currentAnimatedVisualGenerator.CallFactoryFor(obj);

        // Makes the given name suitable for use as a class name in languages such as C# and C++.
        static string SanitizeTypeName(string name)
        {
            if (string.IsNullOrWhiteSpace(name))
            {
                return null;
            }

            // If the first character is not a letter, prepend an underscore.
            if (!char.IsLetter(name, 0))
            {
                name = "_" + name;
            }

            // Replace any disallowed character with underscores.
            name =
                new string((from ch in name
                            select char.IsLetterOrDigit(ch) ? ch : '_').ToArray());

            // Remove any duplicated underscores.
            name = name.Replace("__", "_");

            // Capitalize the first letter.
            name = name.ToUpperInvariant().Substring(0, 1) + name.Substring(1);

            return name;
        }

        static void WriteField(CodeBuilder builder, string typeName, string fieldName)
        {
            builder.WriteLine($"{typeName} {fieldName};");
        }

        // Gets the InReferences for node, ignoring those from ExpressionAnimations
        // that have a single instance because they are treated specially (they are initialized inline).
        static IEnumerable<ObjectData> FilteredInRefs(ObjectData node)
        {
            // Examine all of the inrefs to the node.
            foreach (var vertex in node.InReferences)
            {
                var item = vertex.Node;

                // If the inref is from an ExpressionAnimation ...
                if (item.Object is ExpressionAnimation exprAnim)
                {
                    // ... is the animation shared?
                    if (item.InReferences.Length > 1)
                    {
                        yield return item;
                        continue;
                    }

                    // ... is the animation animating a property on the current node or its property set.
                    bool isExpressionOnThisNode = false;

                    var compObject = node.Object as CompositionObject;

                    // Search the animators to find the animator for this ExpressionAnimation.
                    // It will be found iff the ExpressionAnimation is animating this node.
                    foreach (var animator in compObject.Animators.Concat(compObject.Properties.Animators))
                    {
                        if (animator.Animation is ExpressionAnimation animatorExpression &&
                            animatorExpression.Expression == exprAnim.Expression)
                        {
                            isExpressionOnThisNode = true;
                            break;
                        }
                    }

                    if (!isExpressionOnThisNode)
                    {
                        yield return item;
                    }
                }
                else
                {
                    yield return item;
                }
            }
        }

        string String(GenericDataObject value)
        {
            switch (value.Type)
            {
                case GenericDataObjectType.Bool: return _stringifier.Bool(((GenericDataBool)value).Value);
                case GenericDataObjectType.Number: return _stringifier.Double(((GenericDataNumber)value).Value);
                case GenericDataObjectType.String: return _stringifier.String(((GenericDataString)value).Value);
                default: throw new InvalidOperationException();
            }
        }

        string ScopeResolve => _stringifier.ScopeResolve;

        string Deref => _stringifier.Deref;

        string New => _stringifier.New;

        string IAnimatedVisualSourceInfo.ClassName => _className;

        string IAnimatedVisualSourceInfo.ReusableExpressionAnimationFieldName => SingletonExpressionAnimationName;

        string IAnimatedVisualSourceInfo.DurationTicksFieldName => DurationTicksFieldName;

        Vector2 IAnimatedVisualSourceInfo.CompositionDeclaredSize => _compositionDeclaredSize;

        bool IAnimatedVisualSourceInfo.UsesCanvas => _animatedVisualGenerators.Any(f => f.UsesCanvas);

        bool IAnimatedVisualSourceInfo.UsesCanvasEffects => _animatedVisualGenerators.Any(f => f.UsesCanvasEffects);

        bool IAnimatedVisualSourceInfo.UsesCanvasGeometry => _animatedVisualGenerators.Any(f => f.UsesCanvasGeometry);

        bool IAnimatedVisualSourceInfo.UsesNamespaceWindowsUIXamlMedia => _animatedVisualGenerators.Any(f => f.UsesNamespaceWindowsUIXamlMedia);

        bool IAnimatedVisualSourceInfo.UsesStreams => _animatedVisualGenerators.Any(f => f.UsesStreams);

        IReadOnlyList<IAnimatedVisualInfo> IAnimatedVisualSourceInfo.AnimatedVisualInfos => _animatedVisualGenerators;

        bool IAnimatedVisualSourceInfo.UsesCompositeEffect => _animatedVisualGenerators.Any(f => f.UsesCompositeEffect);

        IReadOnlyList<LoadedImageSurfaceInfo> IAnimatedVisualSourceInfo.LoadedImageSurfaceNodes => _loadedImageSurfaceInfos;

        // Writes code that will return the given GenericDataMap as Windows.Data.Json.
        void WriteJsonFactory(CodeBuilder builder, GenericDataMap jsonData, string factoryName)
        {
            builder.WriteLine($"{_stringifier.ReferenceTypeName("JsonObject")} {factoryName}()");
            builder.OpenScope();
            builder.WriteLine($"{_stringifier.Var} result = {New} JsonObject();");
            WritePopulateJsonObject(builder, jsonData, "result", 0);
            builder.WriteLine($"return result;");
            builder.CloseScope();
            builder.WriteLine();
        }

        void WritePopulateJsonArray(CodeBuilder builder, GenericDataList jsonData, string arrayName, int recursionLevel)
        {
            foreach (var value in jsonData)
            {
                if (value is null)
                {
                    builder.WriteLine($"{arrayName}{Deref}Append(JsonValue{Deref}CreateNullValue());");
                }
                else
                {
                    switch (value.Type)
                    {
                        case GenericDataObjectType.Bool:
                            builder.WriteLine($"{arrayName}{Deref}Append(JsonValue{Deref}CreateBooleanValue({String(value)}));");
                            break;
                        case GenericDataObjectType.Number:
                            builder.WriteLine($"{arrayName}{Deref}Append(JsonValue{Deref}CreateNumberValue({String(value)}));");
                            break;
                        case GenericDataObjectType.String:
                            builder.WriteLine($"{arrayName}{Deref}Append(JsonValue{Deref}CreateStringValue({String(value)}));");
                            break;
                        case GenericDataObjectType.List:
                            if (((GenericDataList)value).Count == 0)
                            {
                                builder.WriteLine($"{arrayName}{Deref}Append({New} JsonArray());");
                            }
                            else
                            {
                                var subArrayName = $"jarray_{recursionLevel}";
                                builder.OpenScope();
                                builder.WriteLine($"{_stringifier.Var} {subArrayName} = {New} JsonArray();");
                                builder.WriteLine($"result{Deref}Append({subArrayName});");
                                WritePopulateJsonArray(builder, (GenericDataList)value, subArrayName, recursionLevel + 1);
                                builder.CloseScope();
                            }

                            break;
                        case GenericDataObjectType.Map:
                            if (((GenericDataMap)value).Count == 0)
                            {
                                builder.WriteLine($"{arrayName}{Deref}Append({New} JsonObject());");
                            }
                            else
                            {
                                var subObjectName = $"jobject_{recursionLevel}";
                                builder.OpenScope();
                                builder.WriteLine($"{_stringifier.Var} {subObjectName} = {New} JsonObject();");
                                builder.WriteLine($"result{Deref}Append({subObjectName});");
                                WritePopulateJsonObject(builder, (GenericDataMap)value, subObjectName, recursionLevel + 1);
                                builder.CloseScope();
                            }

                            break;
                        default:
                            throw new InvalidOperationException();
                    }
                }
            }
        }

        void WritePopulateJsonObject(CodeBuilder builder, GenericDataMap jsonData, string objectName, int recursionLevel)
        {
            foreach (var pair in jsonData)
            {
                var k = _stringifier.String(pair.Key);
                var value = pair.Value;

                if (value is null)
                {
                    builder.WriteLine($"{objectName}{Deref}Add({k}, JsonValue{Deref}CreateNullValue());");
                }
                else
                {
                    switch (value.Type)
                    {
                        case GenericDataObjectType.Bool:
                            builder.WriteLine($"{objectName}{Deref}Add({k}, JsonValue{Deref}CreateBooleanValue({String(value)}));");
                            break;
                        case GenericDataObjectType.Number:
                            builder.WriteLine($"{objectName}{Deref}Add({k}, JsonValue{Deref}CreateNumberValue({String(value)}));");
                            break;
                        case GenericDataObjectType.String:
                            builder.WriteLine($"{objectName}{Deref}Add({k}, JsonValue{Deref}CreateStringValue({String(value)}));");
                            break;
                        case GenericDataObjectType.List:
                            if (((GenericDataList)value).Count == 0)
                            {
                                builder.WriteLine($"{objectName}{Deref}Add({k}, {New} JsonArray());");
                            }
                            else
                            {
                                var subArrayName = $"jarray_{recursionLevel}";
                                builder.OpenScope();
                                builder.WriteLine($"{_stringifier.Var} {subArrayName} = {New} JsonArray();");
                                builder.WriteLine($"result{Deref}Add({k}, {subArrayName});");
                                WritePopulateJsonArray(builder, (GenericDataList)value, subArrayName, recursionLevel + 1);
                                builder.CloseScope();
                            }

                            break;
                        case GenericDataObjectType.Map:
                            if (((GenericDataMap)value).Count == 0)
                            {
                                builder.WriteLine($"{objectName}{Deref}Add({k}, {New} JsonObject());");
                            }
                            else
                            {
                                var subObjectName = $"jobject_{recursionLevel}";
                                builder.OpenScope();
                                builder.WriteLine($"{_stringifier.Var} {subObjectName} = {New} JsonObject();");
                                builder.WriteLine($"result{Deref}Add({k}, {subObjectName});");
                                WritePopulateJsonObject(builder, (GenericDataMap)value, subObjectName, recursionLevel + 1);
                                builder.CloseScope();
                            }

                            break;
                        default:
                            throw new InvalidOperationException();
                    }
                }
            }
        }

        // Write the LoadedImageSurface byte arrays into the outer (IAnimatedVisualSource) class.
        void WriteLoadedImageSurfaceArrays(CodeBuilder builder)
        {
            bool bytesWritten = false;

            foreach (var loadedImageSurface in _loadedImageSurfaceInfos)
            {
                if (loadedImageSurface.Bytes != null)
                {
                    WriteBytesField(builder, loadedImageSurface.BytesFieldName);
                    builder.OpenScope();
                    builder.BytesToLiteral(loadedImageSurface.Bytes, maximumColumns: 100);
                    builder.UnIndent();
                    builder.WriteLine("};");
                    bytesWritten = true;
                }
            }

            if (bytesWritten)
            {
                builder.WriteLine();
            }
        }

        static LoadedImageSurfaceInfo LoadedImageSurfaceInfoFromObjectData(ObjectData node)
        {
            if (!node.IsLoadedImageSurface)
            {
                throw new InvalidOperationException();
            }

            var bytes = (node.Object as Wmd.LoadedImageSurfaceFromStream)?.Bytes;
            return new LoadedImageSurfaceInfo(
                                node.TypeName,
                                node.Name,
                                node.FieldName,
                                node.LoadedImageSurfaceBytesFieldName,
                                node.LoadedImageSurfaceImageUri,
                                ((Wmd.LoadedImageSurface)node.Object).Type,
                                bytes: bytes);
        }

        // Orders nodes by their name using alpha-numeric ordering (which is the most natural ordering for code
        // names that contain embedded numbers).
        static IEnumerable<ObjectData> OrderByName(IEnumerable<ObjectData> nodes) =>
            nodes.OrderBy(n => n.Name, AlphanumericStringComparer.Instance);

        /// <summary>
        /// Generates an IAnimatedVisual implementation.
        /// </summary>
        sealed class AnimatedVisualGenerator : IAnimatedVisualInfo
        {
            readonly HashSet<(ObjectData, ObjectData)> _factoriesAlreadyCalled = new HashSet<(ObjectData, ObjectData)>();
            readonly InstantiatorGeneratorBase _owner;
            readonly Stringifier _stringifier;
            readonly ObjectData _rootNode;
            readonly ObjectGraph<ObjectData> _objectGraph;
            readonly uint _requiredUapVersion;

            // The subset of the object graph for which nodes will be generated.
            readonly ObjectData[] _nodes;

            // Holds the node for which a factory is currently being written.
            ObjectData _currentObjectFactoryNode;

            internal AnimatedVisualGenerator(
                InstantiatorGeneratorBase owner,
                string className,
                CompositionObject graphRoot,
                uint requiredUapVersion)
            {
                _owner = owner;
                _stringifier = _owner._stringifier;
                _requiredUapVersion = requiredUapVersion;

                // Build the object graph.
                _objectGraph = ObjectGraph<ObjectData>.FromCompositionObject(graphRoot, includeVertices: true);

                // Filter out ExpressionAnimations that are unique. They will use a single instance that is reset on each use.
                // TODO - should look at the distinct inrefs - i.e. how many objects are referencing, to deal with objects that reference multiple times.
                var nodes =
                    from node in _objectGraph.Nodes
                    where !(node.Object is ExpressionAnimation) ||
                            node.InReferences.Length > 1
                    select node;

                // Filter out types for which we won't create objects:
                //  AnimationController is created implicitly.
                //  CompositionPropertySet is created implicitly.
                nodes =
                    (from node in nodes
                     where node.Type != Graph.NodeType.CompositionObject ||
                         !(((CompositionObject)node.Object).Type == CompositionObjectType.AnimationController ||
                          ((CompositionObject)node.Object).Type == CompositionObjectType.CompositionPropertySet)
                     select node).Distinct().ToArray();

                // Give names to each node, except the nodes that may be shared by multiple IAnimatedVisuals.
                foreach ((var n, var name) in NodeNamer<ObjectData>.GenerateNodeNames(nodes.Where(n => !n.IsShareableNode)))
                {
                    n.Name = name;
                }

                // Give the root node a special name.
                _rootNode = NodeFor(graphRoot);
                _rootNode.Name = "Root";

                // Save the nodes, ordered by the name that was just set.
                _nodes = OrderByName(nodes).ToArray();

                // Force storage to be allocated for nodes that have multiple references to them,
                // or is a LoadedImageSurface.
                foreach (var node in _nodes)
                {
                    if (FilteredInRefs(node).Count() > 1 || node.IsLoadedImageSurface)
                    {
                        // Node is referenced more than once or is a LoadedImageSurface, so it requires storage.
                        node.RequiresStorage = true;

                        if (node.IsLoadedImageSurface)
                        {
                            // Node is a LoadedImageSurface which requires read-only storage.
                            node.RequiresReadonlyStorage = true;
                        }
                    }
                }

                // Force inlining on CompositionPath nodes that are only referenced once, because they are always very simple.
                foreach (var node in _nodes)
                {
                    if (node.Type == Graph.NodeType.CompositionPath && FilteredInRefs(node).Count() == 1)
                    {
                        node.RequiresStorage = false;
                        var pathSourceFactoryCall = CallFactoryFromFor(node, ((CompositionPath)node.Object).Source);
                        node.ForceInline($"{New} CompositionPath({_stringifier.FactoryCall(pathSourceFactoryCall)})");
                    }
                }

                // Ensure the root object has storage if it is referenced by anything else in the graph.
                // This is necessary because the root node is referenced from the instantiator entrypoint
                // but that isn't counted in the InReference.
                // Because the root object is exposed via IAnimatedVisual::RootVisual this means that
                // there must always be storage for the root object.
                _rootNode.RequiresStorage = true;
            }

            internal IAnimatedVisualInfo AnimatedVisualInfo => this;

            // Returns the nodes that can be shared between multiple IAnimatedVisuals.
            internal IEnumerable<ObjectData> GetShareableNodes() => _nodes.Where(n => n.IsShareableNode);

            internal uint RequiredUapVersion => _requiredUapVersion;

            /// <summary>
            /// Gets a list of the <see cref="LoadedImageSurfaceInfo"/> representing the LoadedImageSurface of the AnimatedVisual and its properties.
            /// </summary>
            internal IEnumerable<LoadedImageSurfaceInfo> GetLoadedImageSurfaceInfos()
            {
                return
                    (from n in _nodes
                     where n.IsLoadedImageSurface
                     select _owner._loadedImageSurfaceInfosByNode[n]).OrderBy(n => n.Name, AlphanumericStringComparer.Instance);
            }

            // Returns the node for the given object.
            ObjectData NodeFor(CompositionObject obj) => _objectGraph[obj];

            ObjectData NodeFor(CompositionPath obj) => _objectGraph[obj];

            ObjectData NodeFor(Wg.IGeometrySource2D obj) => _objectGraph[obj];

            ObjectData NodeFor(Wmd.LoadedImageSurface obj) => _objectGraph[obj];

            internal bool UsesCanvas => _nodes.Where(n => n.UsesCanvas).Any();

            internal bool UsesCanvasEffects => _nodes.Where(n => n.UsesCanvasEffects).Any();

            internal bool UsesCanvasGeometry => _nodes.Where(n => n.UsesCanvasGeometry).Any();

            internal bool UsesNamespaceWindowsUIXamlMedia => _nodes.Where(n => n.UsesNamespaceWindowsUIXamlMedia).Any();

            internal bool UsesStreams => _nodes.Where(n => n.UsesStream).Any();

            internal bool HasLoadedImageSurface => _nodes.Where(n => n.IsLoadedImageSurface).Any();

            internal bool UsesCompositeEffect => _nodes.Where(n => n.UsesCompositeEffect).Any();

            string ScopeResolve => _stringifier.ScopeResolve;

            string Const(string value) => _stringifier.Const(value);

            string Deref => _stringifier.Deref;

            string New => _stringifier.New;

            string Null => _stringifier.Null;

            string Var => _stringifier.Var;

            string Bool(bool value) => _stringifier.Bool(value);

            string Color(Color value) => _stringifier.Color(value);

            string IListAdd => _stringifier.IListAdd;

            string Float(float value) => _stringifier.Float(value);

            string Int(int value) => _stringifier.Int32(value);

            string Matrix3x2(Matrix3x2 value) => _stringifier.Matrix3x2(value);

            string Matrix4x4(Matrix4x4 value) => _stringifier.Matrix4x4(value);

            // readonly on C#, const on C++.
            string Readonly(string value) => _stringifier.Readonly(value);

            string String(string value) => _stringifier.String(value);

            string Vector2(Vector2 value) => _stringifier.Vector2(value);

            string Vector3(Vector3 value) => _stringifier.Vector3(value);

            string Vector4(Vector4 value) => _stringifier.Vector4(value);

            string BorderMode(CompositionBorderMode value) => _stringifier.BorderMode(value);

            string ColorSpace(CompositionColorSpace value) => _stringifier.ColorSpace(value);

            string ExtendMode(CompositionGradientExtendMode value) => _stringifier.ExtendMode(value);

            string MappingMode(CompositionMappingMode value) => _stringifier.MappingMode(value);

            string StrokeCap(CompositionStrokeCap value) => _stringifier.StrokeCap(value);

            string StrokeLineJoin(CompositionStrokeLineJoin value) => _stringifier.StrokeLineJoin(value);

            string TimeSpan(TimeSpan value) => value == _owner._compositionDuration ? _stringifier.TimeSpan(DurationTicksFieldName) : _stringifier.TimeSpan(value);

            /// <summary>
            /// Returns the code to call the factory for the given object.
            /// </summary>
            /// <returns>The code to call the factory for the given object.</returns>
            internal string CallFactoryFor(CanvasGeometry obj)
                => CallFactoryFromFor(_currentObjectFactoryNode, obj);

            // Returns the code to call the factory for the given node from the given node.
            string CallFactoryFromFor(ObjectData callerNode, ObjectData calleeNode)
            {
                if (callerNode.CallFactoryFromForCache.TryGetValue(calleeNode, out string result))
                {
                    // Return the factory from the cache.
                    return result;
                }

                // Get the factory call code.
                result = CallFactoryFromFor_UnCached(callerNode, calleeNode);

                // Save the factory call code in the cache on the caller for next time.
                if (calleeNode.RequiresStorage && !_owner._disableFieldOptimization)
                {
                    // The node has storage for its result. Next time just return the field.
                    callerNode.CallFactoryFromForCache.Add(calleeNode, calleeNode.FieldName);
                }
                else
                {
                    callerNode.CallFactoryFromForCache.Add(calleeNode, result);
                }

                return result;
            }

            // Returns the code to call the factory for the given node from the given node.
            string CallFactoryFromFor_UnCached(ObjectData callerNode, ObjectData calleeNode)
            {
                // Calling into the root node is handled specially. The root node is always
                // created before the first vertex to it, so it is sufficient to just get
                // it from its field.
                if (calleeNode == _rootNode)
                {
                    Debug.Assert(calleeNode.RequiresStorage, "Root node is not stored in a field");
                    return calleeNode.FieldName;
                }

                if (_owner._disableFieldOptimization)
                {
                    // When field optimization is disabled, always return a call to the factory.
                    // If the factory has been called already, it will return the value from
                    // its storage.
                    return calleeNode.FactoryCall();
                }

                // Find the vertex from caller to callee.
                var firstVertexFromCallerToCallee =
                        (from inref in calleeNode.InReferences
                         where inref.Node == callerNode
                         orderby inref.Position
                         select inref).First();

                // Find the first vertex to the callee from any caller.
                var firstVertexToCallee = calleeNode.InReferences.First();

                // If the object has a vertex with a lower position then the object
                // will have already been created by the time the caller needs the object.
                if (firstVertexToCallee.Position < firstVertexFromCallerToCallee.Position)
                {
                    // The object was created by another caller. Just access the field.
                    Debug.Assert(calleeNode.RequiresStorage, "Expecting to access a field containing a previously cached value, but the callee has no field");
                    return calleeNode.FieldName;
                }
                else if (calleeNode.RequiresStorage && _factoriesAlreadyCalled.Contains((callerNode, calleeNode)))
                {
                    return calleeNode.FieldName;
                }
                else
                {
                    // Keep track of the fact that the caller called the factory
                    // already. If the caller asks for the factory twice and the factory
                    // does not have a cache, then the caller was expected to store the
                    // result in a local.
                    // NOTE: currently there is no generated code that is known to hit this case,
                    // so this is just here to ensure we find it if it happens.
                    if (!_factoriesAlreadyCalled.Add((callerNode, calleeNode)))
                    {
                        throw new InvalidOperationException();
                    }

                    return calleeNode.FactoryCall();
                }
            }

            // Returns the code to call the factory for the given object from the given node.
            string CallFactoryFromFor(ObjectData callerNode, CompositionObject obj) => CallFactoryFromFor(callerNode, NodeFor(obj));

            string CallFactoryFromFor(ObjectData callerNode, CompositionPath obj) => CallFactoryFromFor(callerNode, NodeFor(obj));

            string CallFactoryFromFor(ObjectData callerNode, Wg.IGeometrySource2D obj) => CallFactoryFromFor(callerNode, NodeFor(obj));

            bool GenerateCompositionPathFactory(CodeBuilder builder, CompositionPath obj, ObjectData node)
            {
                var canvasGeometry = _objectGraph[(CanvasGeometry)obj.Source];
                WriteObjectFactoryStart(builder, node);
                WriteCreateAssignment(builder, node, $"{New} CompositionPath({_stringifier.FactoryCall(canvasGeometry.FactoryCall())})");
                WriteObjectFactoryEnd(builder);
                return true;
            }

            void WriteObjectFactoryStartWithoutCache(CodeBuilder builder, ObjectData node, IEnumerable<string> parameters = null)
            {
                // Save the node as the current node while the factory is being written.
                _currentObjectFactoryNode = node;
                builder.WriteLine($"{_owner._stringifier.ReferenceTypeName(node.TypeName)} {node.Name}({(parameters == null ? string.Empty : string.Join(", ", parameters))})");
                builder.OpenScope();
            }

            void WriteObjectFactoryEnd(CodeBuilder builder)
            {
                builder.WriteLine("return result;");
                builder.CloseScope();
                builder.WriteLine();
                _currentObjectFactoryNode = null;
            }

            void WriteObjectFactoryStart(CodeBuilder builder, ObjectData node, IEnumerable<string> parameters = null)
            {
                builder.WriteComment(node.LongComment);
                WriteObjectFactoryStartWithoutCache(builder, node, parameters);
            }

            internal void WriteAnimatedVisualCode(CodeBuilder builder)
            {
                _owner._currentAnimatedVisualGenerator = this;

                // Write the body of the AnimatedVisual class.
                _owner.WriteAnimatedVisualStart(builder, this);

                // Write fields for constant values.
                builder.WriteComment($"Animation duration: {_owner._compositionDuration.Ticks / (double)System.TimeSpan.TicksPerSecond,-1:N3} seconds.");
                WriteField(builder, Const(_stringifier.Int64TypeName), $"{DurationTicksFieldName} = {_stringifier.Int64(_owner._compositionDuration.Ticks)}");

                // Write fields for each object that needs storage (i.e. objects that are
                // referenced more than once).
                // Write read-only fields first.
                WriteField(builder, Readonly(_stringifier.ReferenceTypeName("Compositor")), "_c");
                WriteField(builder, Readonly(_stringifier.ReferenceTypeName("ExpressionAnimation")), SingletonExpressionAnimationName);

                WriteFields(builder);

                builder.WriteLine();

                // Write methods for each node.
                foreach (var node in _nodes)
                {
                    WriteCodeForNode(builder, node);
                }

                // Write the end of the AnimatedVisual class.
                _owner.WriteAnimatedVisualEnd(builder, this);

                _owner._currentAnimatedVisualGenerator = null;
            }

            void WriteFields(CodeBuilder builder)
            {
                foreach (var node in OrderByName(_nodes.Where(n => n.RequiresReadonlyStorage)))
                {
                    // Generate a field for the read-only storage.
                    WriteField(builder, Readonly(_stringifier.ReferenceTypeName(node.TypeName)), node.FieldName);
                }

                foreach (var node in OrderByName(_nodes.Where(n => n.RequiresStorage && !n.RequiresReadonlyStorage)))
                {
                    // Generate a field for the storage.
                    WriteField(builder, _stringifier.ReferenceTypeName(node.TypeName), node.FieldName);
                }
            }

            // Generates code for the given node. The code is written into the given CodeBuilder.
            void WriteCodeForNode(CodeBuilder builder, ObjectData node)
            {
                // Only generate if the node is not inlined into the caller.
                if (!node.Inlined)
                {
                    switch (node.Type)
                    {
                        case Graph.NodeType.CompositionObject:
                            GenerateObjectFactory(builder, (CompositionObject)node.Object, node);
                            break;
                        case Graph.NodeType.CompositionPath:
                            GenerateCompositionPathFactory(builder, (CompositionPath)node.Object, node);
                            break;
                        case Graph.NodeType.CanvasGeometry:
                            GenerateCanvasGeometryFactory(builder, (CanvasGeometry)node.Object, node);
                            break;
                        case Graph.NodeType.LoadedImageSurface:
                            // LoadedImageSurface is written out in the IDynamicAnimatedVisualSource class, so does not need to do anything here.
                            break;
                        default:
                            throw new InvalidOperationException();
                    }
                }
            }

            bool GenerateCanvasGeometryFactory(CodeBuilder builder, CanvasGeometry obj, ObjectData node)
            {
                WriteObjectFactoryStart(builder, node);
                var typeName = _stringifier.ReferenceTypeName(node.TypeName);
                var fieldName = node.FieldName;

                switch (obj.Type)
                {
                    case CanvasGeometry.GeometryType.Combination:
                        _owner.WriteCanvasGeometryCombinationFactory(builder, (CanvasGeometry.Combination)obj, typeName, fieldName);
                        break;
                    case CanvasGeometry.GeometryType.Ellipse:
                        _owner.WriteCanvasGeometryEllipseFactory(builder, (CanvasGeometry.Ellipse)obj, typeName, fieldName);
                        break;
                    case CanvasGeometry.GeometryType.Group:
                        _owner.WriteCanvasGeometryGroupFactory(builder, (CanvasGeometry.Group)obj, typeName, fieldName);
                        break;
                    case CanvasGeometry.GeometryType.Path:
                        _owner.WriteCanvasGeometryPathFactory(builder, (CanvasGeometry.Path)obj, typeName, fieldName);
                        break;
                    case CanvasGeometry.GeometryType.RoundedRectangle:
                        _owner.WriteCanvasGeometryRoundedRectangleFactory(builder, (CanvasGeometry.RoundedRectangle)obj, typeName, fieldName);
                        break;
                    case CanvasGeometry.GeometryType.TransformedGeometry:
                        _owner.WriteCanvasGeometryTransformedGeometryFactory(builder, (CanvasGeometry.TransformedGeometry)obj, typeName, fieldName);
                        break;
                    default:
                        throw new InvalidOperationException();
                }

                WriteObjectFactoryEnd(builder);
                return true;
            }

            bool GenerateObjectFactory(CodeBuilder builder, CompositionObject obj, ObjectData node)
            {
                // Uncomment to see the order of creation.
                //builder.WriteComment($"Traversal order: {node.Position}");
                switch (obj.Type)
                {
                    case CompositionObjectType.AnimationController:
                        // Do not generate code for animation controllers. It is done inline in the CompositionObject initialization.
                        throw new InvalidOperationException();
                    case CompositionObjectType.ColorKeyFrameAnimation:
                        return GenerateColorKeyFrameAnimationFactory(builder, (ColorKeyFrameAnimation)obj, node);
                    case CompositionObjectType.CompositionColorBrush:
                        return GenerateCompositionColorBrushFactory(builder, (CompositionColorBrush)obj, node);
                    case CompositionObjectType.CompositionColorGradientStop:
                        return GenerateCompositionColorGradientStopFactory(builder, (CompositionColorGradientStop)obj, node);
                    case CompositionObjectType.CompositionContainerShape:
                        return GenerateContainerShapeFactory(builder, (CompositionContainerShape)obj, node);
                    case CompositionObjectType.CompositionEffectBrush:
                        return GenerateCompositionEffectBrushFactory(builder, (CompositionEffectBrush)obj, node);
                    case CompositionObjectType.CompositionEllipseGeometry:
                        return GenerateCompositionEllipseGeometryFactory(builder, (CompositionEllipseGeometry)obj, node);
                    case CompositionObjectType.CompositionGeometricClip:
                        return GenerateCompositionGeometricClipFactory(builder, (CompositionGeometricClip)obj, node);
                    case CompositionObjectType.CompositionLinearGradientBrush:
                        return GenerateCompositionLinearGradientBrushFactory(builder, (CompositionLinearGradientBrush)obj, node);
                    case CompositionObjectType.CompositionPathGeometry:
                        return GenerateCompositionPathGeometryFactory(builder, (CompositionPathGeometry)obj, node);
                    case CompositionObjectType.CompositionPropertySet:
                        // Do not generate code for property sets. It is done inline in the CompositionObject initialization.
                        return true;
                    case CompositionObjectType.CompositionRadialGradientBrush:
                        return GenerateCompositionRadialGradientBrushFactory(builder, (CompositionRadialGradientBrush)obj, node);
                    case CompositionObjectType.CompositionRectangleGeometry:
                        return GenerateCompositionRectangleGeometryFactory(builder, (CompositionRectangleGeometry)obj, node);
                    case CompositionObjectType.CompositionRoundedRectangleGeometry:
                        return GenerateCompositionRoundedRectangleGeometryFactory(builder, (CompositionRoundedRectangleGeometry)obj, node);
                    case CompositionObjectType.CompositionSpriteShape:
                        return GenerateSpriteShapeFactory(builder, (CompositionSpriteShape)obj, node);
                    case CompositionObjectType.CompositionSurfaceBrush:
                        return GenerateCompositionSurfaceBrushFactory(builder, (CompositionSurfaceBrush)obj, node);
                    case CompositionObjectType.CompositionViewBox:
                        return GenerateCompositionViewBoxFactory(builder, (CompositionViewBox)obj, node);
                    case CompositionObjectType.CompositionVisualSurface:
                        return GenerateCompositionVisualSurfaceFactory(builder, (CompositionVisualSurface)obj, node);
                    case CompositionObjectType.ContainerVisual:
                        return GenerateContainerVisualFactory(builder, (ContainerVisual)obj, node);
                    case CompositionObjectType.CubicBezierEasingFunction:
                        return GenerateCubicBezierEasingFunctionFactory(builder, (CubicBezierEasingFunction)obj, node);
                    case CompositionObjectType.ExpressionAnimation:
                        return GenerateExpressionAnimationFactory(builder, (ExpressionAnimation)obj, node);
                    case CompositionObjectType.InsetClip:
                        return GenerateInsetClipFactory(builder, (InsetClip)obj, node);
                    case CompositionObjectType.LinearEasingFunction:
                        return GenerateLinearEasingFunctionFactory(builder, (LinearEasingFunction)obj, node);
                    case CompositionObjectType.PathKeyFrameAnimation:
                        return GeneratePathKeyFrameAnimationFactory(builder, (PathKeyFrameAnimation)obj, node);
                    case CompositionObjectType.ScalarKeyFrameAnimation:
                        return GenerateScalarKeyFrameAnimationFactory(builder, (ScalarKeyFrameAnimation)obj, node);
                    case CompositionObjectType.ShapeVisual:
                        return GenerateShapeVisualFactory(builder, (ShapeVisual)obj, node);
                    case CompositionObjectType.SpriteVisual:
                        return GenerateSpriteVisualFactory(builder, (SpriteVisual)obj, node);
                    case CompositionObjectType.StepEasingFunction:
                        return GenerateStepEasingFunctionFactory(builder, (StepEasingFunction)obj, node);
                    case CompositionObjectType.Vector2KeyFrameAnimation:
                        return GenerateVector2KeyFrameAnimationFactory(builder, (Vector2KeyFrameAnimation)obj, node);
                    case CompositionObjectType.Vector3KeyFrameAnimation:
                        return GenerateVector3KeyFrameAnimationFactory(builder, (Vector3KeyFrameAnimation)obj, node);
                    case CompositionObjectType.Vector4KeyFrameAnimation:
                        return GenerateVector4KeyFrameAnimationFactory(builder, (Vector4KeyFrameAnimation)obj, node);
                    default:
                        throw new InvalidOperationException();
                }
            }

            bool GenerateInsetClipFactory(CodeBuilder builder, InsetClip obj, ObjectData node)
            {
                WriteObjectFactoryStart(builder, node);
                WriteCreateAssignment(builder, node, $"_c{Deref}CreateInsetClip()");
                InitializeCompositionClip(builder, obj, node);

                if (obj.LeftInset != 0)
                {
                    builder.WriteLine($"result{Deref}LeftInset = {Float(obj.LeftInset)}");
                }

                if (obj.RightInset != 0)
                {
                    builder.WriteLine($"result{Deref}RightInset = {Float(obj.RightInset)}");
                }

                if (obj.TopInset != 0)
                {
                    builder.WriteLine($"result{Deref}TopInset = {Float(obj.TopInset)}");
                }

                if (obj.BottomInset != 0)
                {
                    builder.WriteLine($"result{Deref}BottomInset = {Float(obj.BottomInset)}");
                }

                StartAnimations(builder, obj, node);
                WriteObjectFactoryEnd(builder);
                return true;
            }

            bool GenerateCompositionGeometricClipFactory(CodeBuilder builder, CompositionGeometricClip obj, ObjectData node)
            {
                WriteObjectFactoryStart(builder, node);
                WriteCreateAssignment(builder, node, $"_c{Deref}CreateGeometricClip()");
                InitializeCompositionClip(builder, obj, node);

                if (obj.Geometry != null)
                {
                    builder.WriteLine($"result{Deref}Geometry = {CallFactoryFromFor(node, obj.Geometry)};");
                }

                StartAnimations(builder, obj, node);
                WriteObjectFactoryEnd(builder);
                return true;
            }

            bool GenerateCompositionLinearGradientBrushFactory(CodeBuilder builder, CompositionLinearGradientBrush obj, ObjectData node)
            {
                WriteObjectFactoryStart(builder, node);
                WriteCreateAssignment(builder, node, $"_c{Deref}CreateLinearGradientBrush()");
                InitializeCompositionGradientBrush(builder, obj, node);

                if (obj.StartPoint.HasValue)
                {
                    builder.WriteLine($"result{Deref}StartPoint = {Vector2(obj.StartPoint.Value)};");
                }

                if (obj.EndPoint.HasValue)
                {
                    builder.WriteLine($"result{Deref}EndPoint = {Vector2(obj.EndPoint.Value)};");
                }

                StartAnimations(builder, obj, node);
                WriteObjectFactoryEnd(builder);
                return true;
            }

            bool GenerateCompositionRadialGradientBrushFactory(CodeBuilder builder, CompositionRadialGradientBrush obj, ObjectData node)
            {
                WriteObjectFactoryStart(builder, node);
                WriteCreateAssignment(builder, node, $"_c{Deref}CreateRadialGradientBrush()");
                InitializeCompositionGradientBrush(builder, obj, node);

                if (obj.EllipseCenter.HasValue)
                {
                    builder.WriteLine($"result{Deref}EllipseCenter = {Vector2(obj.EllipseCenter.Value)};");
                }

                if (obj.EllipseRadius.HasValue)
                {
                    builder.WriteLine($"result{Deref}EllipseRadius = {Vector2(obj.EllipseRadius.Value)};");
                }

                if (obj.GradientOriginOffset.HasValue)
                {
                    builder.WriteLine($"result{Deref}GradientOriginOffset = {Vector2(obj.GradientOriginOffset.Value)};");
                }

                StartAnimations(builder, obj, node);
                WriteObjectFactoryEnd(builder);
                return true;
            }

            bool GenerateLinearEasingFunctionFactory(CodeBuilder builder, LinearEasingFunction obj, ObjectData node)
            {
                WriteSimpleObjectFactory(builder, node, $"_c{Deref}CreateLinearEasingFunction()");
                return true;
            }

            bool GenerateCubicBezierEasingFunctionFactory(CodeBuilder builder, CubicBezierEasingFunction obj, ObjectData node)
            {
                WriteSimpleObjectFactory(builder, node, $"_c{Deref}CreateCubicBezierEasingFunction({Vector2(obj.ControlPoint1)}, {Vector2(obj.ControlPoint2)})");
                return true;
            }

            bool GenerateStepEasingFunctionFactory(CodeBuilder builder, StepEasingFunction obj, ObjectData node)
            {
                WriteObjectFactoryStart(builder, node);
                WriteCreateAssignment(builder, node, $"_c{Deref}CreateStepEasingFunction()");

                if (obj.FinalStep != 1)
                {
                    builder.WriteLine($"result{Deref}FinalStep = {Int(obj.FinalStep)};");
                }

                if (obj.InitialStep != 0)
                {
                    builder.WriteLine($"result{Deref}InitialStep = {Int(obj.InitialStep)};");
                }

                if (obj.IsFinalStepSingleFrame)
                {
                    builder.WriteLine($"result{Deref}IsFinalStepSingleFrame  = {Bool(obj.IsFinalStepSingleFrame)};");
                }

                if (obj.IsInitialStepSingleFrame)
                {
                    builder.WriteLine($"result{Deref}IsInitialStepSingleFrame  = {Bool(obj.IsInitialStepSingleFrame)};");
                }

                if (obj.StepCount != 1)
                {
                    builder.WriteLine($"result{Deref}StepCount = {Int(obj.StepCount)};");
                }

                WriteObjectFactoryEnd(builder);
                return true;
            }

            bool GenerateContainerVisualFactory(CodeBuilder builder, ContainerVisual obj, ObjectData node)
            {
                WriteObjectFactoryStart(builder, node);
                WriteCreateAssignment(builder, node, $"_c{Deref}CreateContainerVisual()");
                InitializeContainerVisual(builder, obj, node);
                StartAnimations(builder, obj, node);
                WriteObjectFactoryEnd(builder);
                return true;
            }

            bool GenerateExpressionAnimationFactory(CodeBuilder builder, ExpressionAnimation obj, ObjectData node)
            {
                WriteObjectFactoryStart(builder, node);
                WriteCreateAssignment(builder, node, $"_c{Deref}CreateExpressionAnimation()");
                InitializeCompositionAnimation(builder, obj, node);
                builder.WriteLine($"result{Deref}Expression = {String(obj.Expression.ToString())};");
                StartAnimations(builder, obj, node);
                WriteObjectFactoryEnd(builder);
                return true;
            }

            void StartAnimations(CodeBuilder builder, CompositionObject obj, ObjectData node, string localName = "result", string animationNamePrefix = "")
            {
                bool controllerVariableAdded = false;

                // Start the animations for properties on the object.
                foreach (var animator in obj.Animators)
                {
                    StartAnimation(builder, obj, node, localName, ref controllerVariableAdded, animator);
                }

                // Start the animations for properties on the property set.
                foreach (var animator in obj.Properties.Animators)
                {
                    StartAnimation(builder, obj.Properties, NodeFor(obj.Properties), localName, ref controllerVariableAdded, animator);
                }
            }

            void StartAnimation(CodeBuilder builder, CompositionObject obj, ObjectData node, string localName, ref bool controllerVariableAdded, CompositionObject.Animator animator)
            {
                // ExpressionAnimations are treated specially - a singleton
                // ExpressionAnimation is reset before each use, unless the animation
                // is shared.
                var animationNode = NodeFor(animator.Animation);
                if (!animationNode.RequiresStorage && animator.Animation is ExpressionAnimation expressionAnimation)
                {
                    builder.WriteLine($"{SingletonExpressionAnimationName}{Deref}ClearAllParameters();");
                    builder.WriteLine($"{SingletonExpressionAnimationName}{Deref}Expression = {String(expressionAnimation.Expression.ToString())};");

                    // If there is a Target set it. Note however that the Target isn't used for anything
                    // interesting in this scenario, and there is no way to reset the Target to an
                    // empty string (the Target API disallows empty). In reality, for all our uses
                    // the Target will not be set and it doesn't matter if it was set previously.
                    if (!string.IsNullOrWhiteSpace(expressionAnimation.Target))
                    {
                        builder.WriteLine($"{SingletonExpressionAnimationName}{Deref}Target = {String(expressionAnimation.Target)};");
                    }

                    foreach (var rp in expressionAnimation.ReferenceParameters)
                    {
                        var referenceParamenterValueName = rp.Value == obj
                            ? localName
                            : CallFactoryFromFor(animationNode, rp.Value);
                        builder.WriteLine($"{SingletonExpressionAnimationName}{Deref}SetReferenceParameter({String(rp.Key)}, {referenceParamenterValueName});");
                    }

                    builder.WriteLine($"{localName}{Deref}StartAnimation({String(animator.AnimatedProperty)}, {SingletonExpressionAnimationName});");
                }
                else
                {
                    // KeyFrameAnimation or shared animation
                    var animationFactoryCall = CallFactoryFromFor(node, animationNode);
                    builder.WriteLine($"{localName}{Deref}StartAnimation({String(animator.AnimatedProperty)}, {animationFactoryCall});");
                }

                // If the animation has a controller, get the controller, optionally pause it, and recurse to start the animations
                // on the controller.
                if (animator.Controller != null)
                {
                    if (!controllerVariableAdded)
                    {
                        // Declare and initialize the controller variable.
                        builder.WriteLine($"{Var} controller = {localName}{Deref}TryGetAnimationController({String(animator.AnimatedProperty)});");
                        controllerVariableAdded = true;
                    }
                    else
                    {
                        // Initialize the controller variable.
                        builder.WriteLine($"controller = {localName}{Deref}TryGetAnimationController({String(animator.AnimatedProperty)});");
                    }

                    if (animator.Controller.IsPaused)
                    {
                        builder.WriteLine($"controller{Deref}Pause();");
                    }

                    // Recurse to start animations on the controller.
                    StartAnimations(builder, animator.Controller, NodeFor(animator.Controller), "controller", "controller");
                }
            }

            void InitializeCompositionObject(CodeBuilder builder, CompositionObject obj, ObjectData node, string localName = "result", string animationNamePrefix = "")
            {
                if (_owner._setCommentProperties)
                {
                    if (!string.IsNullOrWhiteSpace(obj.Comment))
                    {
                        builder.WriteLine($"{localName}{Deref}Comment = {String(obj.Comment)};");
                    }
                }

                var propertySet = obj.Properties;
                if (!propertySet.IsEmpty)
                {
                    builder.WriteLine($"{Var} propertySet = {localName}{Deref}Properties;");
                    foreach (var prop in propertySet.ColorProperties)
                    {
                        builder.WriteLine($"propertySet{Deref}InsertColor({String(prop.Key)}, {Color(prop.Value)});");
                    }

                    foreach (var prop in propertySet.ScalarProperties)
                    {
                        builder.WriteLine($"propertySet{Deref}InsertScalar({String(prop.Key)}, {Float(prop.Value)});");
                    }

                    foreach (var prop in propertySet.Vector2Properties)
                    {
                        builder.WriteLine($"propertySet{Deref}InsertVector2({String(prop.Key)}, {Vector2(prop.Value)});");
                    }
                }
            }

            void InitializeCompositionBrush(CodeBuilder builder, CompositionBrush obj, ObjectData node)
            {
                InitializeCompositionObject(builder, obj, node);
            }

            void InitializeVisual(CodeBuilder builder, Visual obj, ObjectData node)
            {
                InitializeCompositionObject(builder, obj, node);

                if (obj.BorderMode.HasValue)
                {
                    builder.WriteLine($"result{Deref}BorderMode = {BorderMode(obj.BorderMode.Value)};");
                }

                if (obj.CenterPoint.HasValue)
                {
                    builder.WriteLine($"result{Deref}CenterPoint = {Vector3(obj.CenterPoint.Value)};");
                }

                if (obj.Clip != null)
                {
                    builder.WriteLine($"result{Deref}Clip = {CallFactoryFromFor(node, obj.Clip)};");
                }

                if (obj.Offset.HasValue)
                {
                    builder.WriteLine($"result{Deref}Offset = {Vector3(obj.Offset.Value)};");
                }

                if (obj.Opacity.HasValue)
                {
                    builder.WriteLine($"result{Deref}Opacity = {Float(obj.Opacity.Value)};");
                }

                if (obj.RotationAngleInDegrees.HasValue)
                {
                    builder.WriteLine($"result{Deref}RotationAngleInDegrees = {Float(obj.RotationAngleInDegrees.Value)};");
                }

                if (obj.RotationAxis.HasValue)
                {
                    builder.WriteLine($"result{Deref}RotationAxis = {Vector3(obj.RotationAxis.Value)};");
                }

                if (obj.Scale.HasValue)
                {
                    builder.WriteLine($"result{Deref}Scale = {Vector3(obj.Scale.Value)};");
                }

                if (obj.Size.HasValue)
                {
                    builder.WriteLine($"result{Deref}Size = {Vector2(obj.Size.Value)};");
                }

                if (obj.TransformMatrix.HasValue)
                {
                    builder.WriteLine($"result{Deref}TransformMatrix = {Matrix4x4(obj.TransformMatrix.Value)};");
                }
            }

            void InitializeCompositionClip(CodeBuilder builder, CompositionClip obj, ObjectData node)
            {
                InitializeCompositionObject(builder, obj, node);

                if (obj.CenterPoint.X != 0 || obj.CenterPoint.Y != 0)
                {
                    builder.WriteLine($"result{Deref}CenterPoint = {Vector2(obj.CenterPoint)};");
                }

                if (obj.Scale.X != 1 || obj.Scale.Y != 1)
                {
                    builder.WriteLine($"result{Deref}Scale = {Vector2(obj.Scale)};");
                }
            }

            void InitializeCompositionGradientBrush(CodeBuilder builder, CompositionGradientBrush obj, ObjectData node)
            {
                InitializeCompositionObject(builder, obj, node);
                if (obj.AnchorPoint.HasValue)
                {
                    builder.WriteLine($"result{Deref}AnchorPoint = {Vector2(obj.AnchorPoint.Value)};");
                }

                if (obj.CenterPoint.HasValue)
                {
                    builder.WriteLine($"result{Deref}CenterPoint = {Vector2(obj.CenterPoint.Value)};");
                }

                if (obj.ColorStops.Count > 0)
                {
                    builder.WriteLine($"{Var} colorStops = result{Deref}ColorStops;");
                    foreach (var colorStop in obj.ColorStops)
                    {
                        builder.WriteLine($"colorStops{Deref}{IListAdd}({CallFactoryFromFor(node, colorStop)});");
                    }
                }

                if (obj.ExtendMode.HasValue)
                {
                    builder.WriteLine($"result{Deref}ExtendMode = {ExtendMode(obj.ExtendMode.Value)};");
                }

                if (obj.InterpolationSpace.HasValue)
                {
                    builder.WriteLine($"result{Deref}InterpolationSpace = {ColorSpace(obj.InterpolationSpace.Value)};");
                }

                // Default MappingMode is Relative
                if (obj.MappingMode.HasValue && obj.MappingMode.Value != CompositionMappingMode.Relative)
                {
                    builder.WriteLine($"result{Deref}MappingMode = {MappingMode(obj.MappingMode.Value)};");
                }

                if (obj.Offset.HasValue)
                {
                    builder.WriteLine($"result{Deref}Offset = {Vector2(obj.Offset.Value)}");
                }

                if (obj.RotationAngleInDegrees.HasValue)
                {
                    builder.WriteLine($"result{Deref}RotationAngleInDegrees = {Float(obj.RotationAngleInDegrees.Value)}");
                }

                if (obj.Scale.HasValue)
                {
                    builder.WriteLine($"result{Deref}Scale = {Vector2(obj.Scale.Value)}");
                }

                if (obj.TransformMatrix.HasValue)
                {
                    builder.WriteLine($"result{Deref}TransformMatrix = {Matrix3x2(obj.TransformMatrix.Value)}");
                }
            }

            void InitializeCompositionShape(CodeBuilder builder, CompositionShape obj, ObjectData node)
            {
                InitializeCompositionObject(builder, obj, node);

                if (obj.CenterPoint.HasValue)
                {
                    builder.WriteLine($"result{Deref}CenterPoint = {Vector2(obj.CenterPoint.Value)};");
                }

                if (obj.Offset != null)
                {
                    builder.WriteLine($"result{Deref}Offset = {Vector2(obj.Offset.Value)};");
                }

                if (obj.RotationAngleInDegrees.HasValue)
                {
                    builder.WriteLine($"result{Deref}RotationAngleInDegrees = {Float(obj.RotationAngleInDegrees.Value)};");
                }

                if (obj.Scale.HasValue)
                {
                    builder.WriteLine($"result{Deref}Scale = {Vector2(obj.Scale.Value)};");
                }

                if (obj.TransformMatrix.HasValue)
                {
                    builder.WriteLine($"result{Deref}TransformMatrix = {Matrix3x2(obj.TransformMatrix.Value)};");
                }
            }

            void InitializeContainerVisual(CodeBuilder builder, ContainerVisual obj, ObjectData node)
            {
                InitializeVisual(builder, obj, node);

                if (obj.Children.Any())
                {
                    builder.WriteLine($"{Var} children = result{Deref}Children;");
                    foreach (var child in obj.Children)
                    {
                        builder.WriteLine($"children{Deref}InsertAtTop({CallFactoryFromFor(node, child)});");
                    }
                }
            }

            void InitializeCompositionGeometry(CodeBuilder builder, CompositionGeometry obj, ObjectData node)
            {
                InitializeCompositionObject(builder, obj, node);

                if (obj.TrimEnd != 1)
                {
                    builder.WriteLine($"result{Deref}TrimEnd = {Float(obj.TrimEnd)};");
                }

                if (obj.TrimOffset != 0)
                {
                    builder.WriteLine($"result{Deref}TrimOffset = {Float(obj.TrimOffset)};");
                }

                if (obj.TrimStart != 0)
                {
                    builder.WriteLine($"result{Deref}TrimStart = {Float(obj.TrimStart)};");
                }
            }

            void InitializeCompositionAnimation(CodeBuilder builder, CompositionAnimation obj, ObjectData node)
            {
                InitializeCompositionAnimationWithParameters(
                    builder,
                    obj,
                    node,
                    obj.ReferenceParameters.Select(p => new KeyValuePair<string, string>(p.Key, $"{CallFactoryFromFor(node, p.Value)}")));
            }

            void InitializeCompositionAnimationWithParameters(CodeBuilder builder, CompositionAnimation obj, ObjectData node, IEnumerable<KeyValuePair<string, string>> parameters)
            {
                InitializeCompositionObject(builder, obj, node);
                if (!string.IsNullOrWhiteSpace(obj.Target))
                {
                    builder.WriteLine($"result{Deref}Target = {String(obj.Target)};");
                }

                foreach (var parameter in parameters)
                {
                    builder.WriteLine($"result{Deref}SetReferenceParameter({String(parameter.Key)}, {parameter.Value});");
                }
            }

            void InitializeKeyFrameAnimation(CodeBuilder builder, KeyFrameAnimation_ obj, ObjectData node)
            {
                InitializeCompositionAnimation(builder, obj, node);
                builder.WriteLine($"result{Deref}Duration = {TimeSpan(obj.Duration)};");
            }

            bool GenerateColorKeyFrameAnimationFactory(CodeBuilder builder, ColorKeyFrameAnimation obj, ObjectData node)
            {
                WriteObjectFactoryStart(builder, node);
                WriteCreateAssignment(builder, node, $"_c{Deref}CreateColorKeyFrameAnimation()");
                InitializeKeyFrameAnimation(builder, obj, node);

                if (obj.InterpolationColorSpace != CompositionColorSpace.Auto)
                {
                    builder.WriteLine($"result{Deref}InterpolationColorSpace = {ColorSpace(obj.InterpolationColorSpace)};");
                }

                foreach (var kf in obj.KeyFrames)
                {
                    switch (kf.Type)
                    {
                        case KeyFrameAnimation<Color>.KeyFrameType.Expression:
                            var expressionKeyFrame = (KeyFrameAnimation<Color>.ExpressionKeyFrame)kf;
                            builder.WriteLine($"result{Deref}InsertExpressionKeyFrame({Float(kf.Progress)}, {String(expressionKeyFrame.Expression)}, {CallFactoryFromFor(node, kf.Easing)});");
                            break;
                        case KeyFrameAnimation<Color>.KeyFrameType.Value:
                            var valueKeyFrame = (KeyFrameAnimation<Color>.ValueKeyFrame)kf;
                            builder.WriteComment(valueKeyFrame.Value.Name);
                            builder.WriteLine($"result{Deref}InsertKeyFrame({Float(kf.Progress)}, {Color(valueKeyFrame.Value)}, {CallFactoryFromFor(node, kf.Easing)});");
                            break;
                        default:
                            throw new InvalidOperationException();
                    }
                }

                StartAnimations(builder, obj, node);
                WriteObjectFactoryEnd(builder);
                return true;
            }

            bool GenerateVector2KeyFrameAnimationFactory(CodeBuilder builder, Vector2KeyFrameAnimation obj, ObjectData node)
            {
                WriteObjectFactoryStart(builder, node);
                WriteCreateAssignment(builder, node, $"_c{Deref}CreateVector2KeyFrameAnimation()");
                InitializeKeyFrameAnimation(builder, obj, node);

                foreach (var kf in obj.KeyFrames)
                {
                    switch (kf.Type)
                    {
                        case KeyFrameAnimation<Vector2>.KeyFrameType.Expression:
                            var expressionKeyFrame = (KeyFrameAnimation<Vector2>.ExpressionKeyFrame)kf;
                            builder.WriteLine($"result{Deref}InsertExpressionKeyFrame({Float(kf.Progress)}, {String(expressionKeyFrame.Expression)}, {CallFactoryFromFor(node, kf.Easing)});");
                            break;
                        case KeyFrameAnimation<Vector2>.KeyFrameType.Value:
                            var valueKeyFrame = (KeyFrameAnimation<Vector2>.ValueKeyFrame)kf;
                            builder.WriteLine($"result{Deref}InsertKeyFrame({Float(kf.Progress)}, {Vector2(valueKeyFrame.Value)}, {CallFactoryFromFor(node, kf.Easing)});");
                            break;
                        default:
                            throw new InvalidOperationException();
                    }
                }

                StartAnimations(builder, obj, node);
                WriteObjectFactoryEnd(builder);
                return true;
            }

            bool GenerateVector3KeyFrameAnimationFactory(CodeBuilder builder, Vector3KeyFrameAnimation obj, ObjectData node)
            {
                WriteObjectFactoryStart(builder, node);
                WriteCreateAssignment(builder, node, $"_c{Deref}CreateVector3KeyFrameAnimation()");
                InitializeKeyFrameAnimation(builder, obj, node);

                foreach (var kf in obj.KeyFrames)
                {
                    switch (kf.Type)
                    {
                        case KeyFrameAnimation<Vector3>.KeyFrameType.Expression:
                            var expressionKeyFrame = (KeyFrameAnimation<Vector3>.ExpressionKeyFrame)kf;
                            builder.WriteLine($"result{Deref}InsertExpressionKeyFrame({Float(kf.Progress)}, {String(expressionKeyFrame.Expression)}, {CallFactoryFromFor(node, kf.Easing)});");
                            break;
                        case KeyFrameAnimation<Vector3>.KeyFrameType.Value:
                            var valueKeyFrame = (KeyFrameAnimation<Vector3>.ValueKeyFrame)kf;
                            builder.WriteLine($"result{Deref}InsertKeyFrame({Float(kf.Progress)}, {Vector3(valueKeyFrame.Value)}, {CallFactoryFromFor(node, kf.Easing)});");
                            break;
                        default:
                            throw new InvalidOperationException();
                    }
                }

                StartAnimations(builder, obj, node);
                WriteObjectFactoryEnd(builder);
                return true;
            }

            bool GenerateVector4KeyFrameAnimationFactory(CodeBuilder builder, Vector4KeyFrameAnimation obj, ObjectData node)
            {
                WriteObjectFactoryStart(builder, node);
                WriteCreateAssignment(builder, node, $"_c{Deref}CreateVector4KeyFrameAnimation()");
                InitializeKeyFrameAnimation(builder, obj, node);

                foreach (var kf in obj.KeyFrames)
                {
                    switch (kf.Type)
                    {
                        case KeyFrameAnimation<Vector4>.KeyFrameType.Expression:
                            var expressionKeyFrame = (KeyFrameAnimation<Vector4>.ExpressionKeyFrame)kf;
                            builder.WriteLine($"result{Deref}InsertExpressionKeyFrame({Float(kf.Progress)}, {String(expressionKeyFrame.Expression)}, {CallFactoryFromFor(node, kf.Easing)});");
                            break;
                        case KeyFrameAnimation<Vector4>.KeyFrameType.Value:
                            var valueKeyFrame = (KeyFrameAnimation<Vector4>.ValueKeyFrame)kf;
                            builder.WriteLine($"result{Deref}InsertKeyFrame({Float(kf.Progress)}, {Vector4(valueKeyFrame.Value)}, {CallFactoryFromFor(node, kf.Easing)});");
                            break;
                        default:
                            throw new InvalidOperationException();
                    }
                }

                StartAnimations(builder, obj, node);
                WriteObjectFactoryEnd(builder);
                return true;
            }

            bool GeneratePathKeyFrameAnimationFactory(CodeBuilder builder, PathKeyFrameAnimation obj, ObjectData node)
            {
                WriteObjectFactoryStart(builder, node);
                WriteCreateAssignment(builder, node, $"_c{Deref}CreatePathKeyFrameAnimation()");
                InitializeKeyFrameAnimation(builder, obj, node);

                foreach (var kf in obj.KeyFrames)
                {
                    var valueKeyFrame = (PathKeyFrameAnimation.ValueKeyFrame)kf;
                    builder.WriteLine($"result{Deref}InsertKeyFrame({Float(kf.Progress)}, {CallFactoryFromFor(node, valueKeyFrame.Value)}, {CallFactoryFromFor(node, kf.Easing)});");
                }

                StartAnimations(builder, obj, node);
                WriteObjectFactoryEnd(builder);
                return true;
            }

            bool GenerateScalarKeyFrameAnimationFactory(CodeBuilder builder, ScalarKeyFrameAnimation obj, ObjectData node)
            {
                WriteObjectFactoryStart(builder, node);
                WriteCreateAssignment(builder, node, $"_c{Deref}CreateScalarKeyFrameAnimation()");
                InitializeKeyFrameAnimation(builder, obj, node);

                foreach (var kf in obj.KeyFrames)
                {
                    switch (kf.Type)
                    {
                        case KeyFrameAnimation<float>.KeyFrameType.Expression:
                            var expressionKeyFrame = (KeyFrameAnimation<float>.ExpressionKeyFrame)kf;
                            builder.WriteLine($"result{Deref}InsertExpressionKeyFrame({Float(kf.Progress)}, {String(expressionKeyFrame.Expression)}, {CallFactoryFromFor(node, kf.Easing)});");
                            break;
                        case KeyFrameAnimation<float>.KeyFrameType.Value:
                            var valueKeyFrame = (KeyFrameAnimation<float>.ValueKeyFrame)kf;
                            builder.WriteLine($"result{Deref}InsertKeyFrame({Float(kf.Progress)}, {Float(valueKeyFrame.Value)}, {CallFactoryFromFor(node, kf.Easing)});");
                            break;
                        default:
                            throw new InvalidOperationException();
                    }
                }

                StartAnimations(builder, obj, node);
                WriteObjectFactoryEnd(builder);
                return true;
            }

            bool GenerateCompositionRectangleGeometryFactory(CodeBuilder builder, CompositionRectangleGeometry obj, ObjectData node)
            {
                WriteObjectFactoryStart(builder, node);
                WriteCreateAssignment(builder, node, $"_c{Deref}CreateRectangleGeometry()");
                InitializeCompositionGeometry(builder, obj, node);

                if (obj.Offset != null)
                {
                    builder.WriteLine($"result{Deref}Offset = {Vector2(obj.Offset.Value)};");
                }

                builder.WriteLine($"result{Deref}Size = {Vector2(obj.Size)};");
                StartAnimations(builder, obj, node);
                WriteObjectFactoryEnd(builder);
                return true;
            }

            bool GenerateCompositionRoundedRectangleGeometryFactory(CodeBuilder builder, CompositionRoundedRectangleGeometry obj, ObjectData node)
            {
                WriteObjectFactoryStart(builder, node);
                WriteCreateAssignment(builder, node, $"_c{Deref}CreateRoundedRectangleGeometry()");
                InitializeCompositionGeometry(builder, obj, node);
                builder.WriteLine($"result{Deref}CornerRadius = {Vector2(obj.CornerRadius)};");

                if (obj.Offset != null)
                {
                    builder.WriteLine($"result{Deref}Offset = {Vector2(obj.Offset.Value)};");
                }

                builder.WriteLine($"result{Deref}Size = {Vector2(obj.Size)};");
                StartAnimations(builder, obj, node);
                WriteObjectFactoryEnd(builder);
                return true;
            }

            bool GenerateCompositionEllipseGeometryFactory(CodeBuilder builder, CompositionEllipseGeometry obj, ObjectData node)
            {
                WriteObjectFactoryStart(builder, node);
                WriteCreateAssignment(builder, node, $"_c{Deref}CreateEllipseGeometry()");
                InitializeCompositionGeometry(builder, obj, node);

                if (obj.Center.X != 0 || obj.Center.Y != 0)
                {
                    builder.WriteLine($"result{Deref}Center = {Vector2(obj.Center)};");
                }

                builder.WriteLine($"result{Deref}Radius = {Vector2(obj.Radius)};");
                StartAnimations(builder, obj, node);
                WriteObjectFactoryEnd(builder);
                return true;
            }

            bool GenerateCompositionPathGeometryFactory(CodeBuilder builder, CompositionPathGeometry obj, ObjectData node)
            {
                WriteObjectFactoryStart(builder, node);
                if (obj.Path == null)
                {
                    WriteCreateAssignment(builder, node, $"_c{Deref}CreatePathGeometry()");
                }
                else
                {
                    var path = _objectGraph[obj.Path];
                    WriteCreateAssignment(builder, node, $"_c{Deref}CreatePathGeometry({CallFactoryFromFor(node, path)})");
                }

                InitializeCompositionGeometry(builder, obj, node);
                StartAnimations(builder, obj, node);
                WriteObjectFactoryEnd(builder);
                return true;
            }

            bool GenerateCompositionColorBrushFactory(CodeBuilder builder, CompositionColorBrush obj, ObjectData node)
            {
                var createCallText = obj.Color.HasValue
                                        ? $"_c{Deref}CreateColorBrush({Color(obj.Color.Value)})"
                                        : $"_c{Deref}CreateColorBrush()";

                if (obj.Animators.Count > 0)
                {
                    WriteObjectFactoryStart(builder, node);
                    WriteCreateAssignment(builder, node, createCallText);
                    InitializeCompositionBrush(builder, obj, node);
                    StartAnimations(builder, obj, node);
                    WriteObjectFactoryEnd(builder);
                }
                else
                {
                    WriteSimpleObjectFactory(builder, node, createCallText);
                }

                return true;
            }

            bool GenerateCompositionColorGradientStopFactory(CodeBuilder builder, CompositionColorGradientStop obj, ObjectData node)
            {
                if (obj.Animators.Count > 0)
                {
                    WriteObjectFactoryStart(builder, node);
                    WriteCreateAssignment(builder, node, $"_c{Deref}CreateColorGradientStop()");
                    InitializeCompositionObject(builder, obj, node);
                    StartAnimations(builder, obj, node);
                    WriteObjectFactoryEnd(builder);
                }
                else
                {
                    WriteSimpleObjectFactory(builder, node, $"_c{Deref}CreateColorGradientStop({Float(obj.Offset)}, {Color(obj.Color)})");
                }

                return true;
            }

            bool GenerateShapeVisualFactory(CodeBuilder builder, ShapeVisual obj, ObjectData node)
            {
                WriteObjectFactoryStart(builder, node);
                WriteCreateAssignment(builder, node, $"_c{Deref}CreateShapeVisual()");
                InitializeContainerVisual(builder, obj, node);

                if (obj.Shapes.Count > 0)
                {
                    builder.WriteLine($"{Var} shapes = result{Deref}Shapes;");
                    foreach (var shape in obj.Shapes)
                    {
                        builder.WriteComment(((IDescribable)shape).ShortDescription);
                        builder.WriteLine($"shapes{Deref}{IListAdd}({CallFactoryFromFor(node, shape)});");
                    }
                }

                StartAnimations(builder, obj, node);
                WriteObjectFactoryEnd(builder);
                return true;
            }

            bool GenerateSpriteVisualFactory(CodeBuilder builder, SpriteVisual obj, ObjectData node)
            {
                WriteObjectFactoryStart(builder, node);
                WriteCreateAssignment(builder, node, $"_c{Deref}CreateSpriteVisual()");
                InitializeContainerVisual(builder, obj, node);

                if (obj.Brush != null)
                {
                    builder.WriteLine($"result{Deref}Brush = {CallFactoryFromFor(node, obj.Brush)};");
                }

                StartAnimations(builder, obj, node);
                WriteObjectFactoryEnd(builder);
                return true;
            }

            bool GenerateContainerShapeFactory(CodeBuilder builder, CompositionContainerShape obj, ObjectData node)
            {
                WriteObjectFactoryStart(builder, node);
                WriteCreateAssignment(builder, node, $"_c{Deref}CreateContainerShape()");
                InitializeCompositionShape(builder, obj, node);

                if (obj.Shapes.Count > 0)
                {
                    builder.WriteLine($"{Var} shapes = result{Deref}Shapes;");
                    foreach (var shape in obj.Shapes)
                    {
                        builder.WriteLine($"shapes{Deref}{IListAdd}({CallFactoryFromFor(node, shape)});");
                    }
                }

                StartAnimations(builder, obj, node);
                WriteObjectFactoryEnd(builder);
                return true;
            }

            bool GenerateCompositionEffectBrushFactory(CodeBuilder builder, CompositionEffectBrush obj, ObjectData node)
            {
                WriteObjectFactoryStart(builder, node);

                var effect = obj.GetEffect();

                string effectCreationString;
                switch (effect.Type)
                {
                    case Mgce.GraphicsEffectType.CompositeEffect:
                        effectCreationString = _owner.WriteCompositeEffectFactory(builder, (Mgce.CompositeEffect)effect);
                        break;
                    default:
                        // Unsupported GraphicsEffectType.
                        throw new InvalidOperationException();
                }

                builder.WriteLine($"{Var} effectFactory = _c{Deref}CreateEffectFactory({effectCreationString});");
                WriteCreateAssignment(builder, node, $"effectFactory{Deref}CreateBrush()");
                InitializeCompositionBrush(builder, obj, node);

                // Perform brush initialization
                switch (effect.Type)
                {
                    case Mgce.GraphicsEffectType.CompositeEffect:
                        foreach (var sourceParameters in ((Mgce.CompositeEffect)effect).Sources)
                        {
                            builder.WriteLine($"result{Deref}SetSourceParameter({String(sourceParameters.Name)}, {CallFactoryFromFor(node, obj.GetSourceParameter(sourceParameters.Name))});");
                        }

                        break;
                    default:
                        throw new InvalidOperationException();
                }

                StartAnimations(builder, obj, node);
                WriteObjectFactoryEnd(builder);
                return true;
            }

            bool GenerateSpriteShapeFactory(CodeBuilder builder, CompositionSpriteShape obj, ObjectData node)
            {
                WriteObjectFactoryStart(builder, node);
                WriteCreateAssignment(builder, node, $"_c{Deref}CreateSpriteShape()");
                InitializeCompositionShape(builder, obj, node);

                if (obj.FillBrush != null)
                {
                    builder.WriteLine($"result{Deref}FillBrush = {CallFactoryFromFor(node, obj.FillBrush)};");
                }

                if (obj.Geometry != null)
                {
                    builder.WriteLine($"result{Deref}Geometry = {CallFactoryFromFor(node, obj.Geometry)};");
                }

                if (obj.IsStrokeNonScaling)
                {
                    builder.WriteLine("result{Deref}IsStrokeNonScaling = true;");
                }

                if (obj.StrokeBrush != null)
                {
                    builder.WriteLine($"result{Deref}StrokeBrush = {CallFactoryFromFor(node, obj.StrokeBrush)};");
                }

                if (obj.StrokeDashCap != CompositionStrokeCap.Flat)
                {
                    builder.WriteLine($"result{Deref}StrokeDashCap = {StrokeCap(obj.StrokeDashCap)};");
                }

                if (obj.StrokeDashOffset != 0)
                {
                    builder.WriteLine($"result{Deref}StrokeDashOffset = {Float(obj.StrokeDashOffset)};");
                }

                if (obj.StrokeDashArray.Count > 0)
                {
                    builder.WriteLine($"{Var} strokeDashArray = result{Deref}StrokeDashArray;");
                    foreach (var strokeDash in obj.StrokeDashArray)
                    {
                        builder.WriteLine($"strokeDashArray{Deref}{IListAdd}({Float(strokeDash)});");
                    }
                }

                if (obj.StrokeEndCap != CompositionStrokeCap.Flat)
                {
                    builder.WriteLine($"result{Deref}StrokeEndCap = {StrokeCap(obj.StrokeEndCap)};");
                }

                if (obj.StrokeLineJoin != CompositionStrokeLineJoin.Miter)
                {
                    builder.WriteLine($"result{Deref}StrokeLineJoin = {StrokeLineJoin(obj.StrokeLineJoin)};");
                }

                if (obj.StrokeStartCap != CompositionStrokeCap.Flat)
                {
                    builder.WriteLine($"result{Deref}StrokeStartCap = {StrokeCap(obj.StrokeStartCap)};");
                }

                if (obj.StrokeMiterLimit != 1)
                {
                    builder.WriteLine($"result{Deref}StrokeMiterLimit = {Float(obj.StrokeMiterLimit)};");
                }

                if (obj.StrokeThickness != 1)
                {
                    builder.WriteLine($"result{Deref}StrokeThickness = {Float(obj.StrokeThickness)};");
                }

                StartAnimations(builder, obj, node);
                WriteObjectFactoryEnd(builder);
                return true;
            }

            bool GenerateCompositionSurfaceBrushFactory(CodeBuilder builder, CompositionSurfaceBrush obj, ObjectData node)
            {
                WriteObjectFactoryStart(builder, node);
                WriteCreateAssignment(builder, node, $"_c{Deref}CreateSurfaceBrush()");
                InitializeCompositionBrush(builder, obj, node);

                if (obj.Surface != null)
                {
                    switch (obj.Surface)
                    {
                        case CompositionObject compositionObject:
                            builder.WriteLine($"result{Deref}Surface = {CallFactoryFromFor(node, compositionObject)};");
                            break;
                        case Wmd.LoadedImageSurface loadedImageSurface:
                            builder.WriteLine($"result{Deref}Surface = {NodeFor(loadedImageSurface).FieldName};");
                            break;
                        default:
                            throw new InvalidOperationException();
                    }
                }

                StartAnimations(builder, obj, node);
                WriteObjectFactoryEnd(builder);
                return true;
            }

            bool GenerateCompositionViewBoxFactory(CodeBuilder builder, CompositionViewBox obj, ObjectData node)
            {
                WriteObjectFactoryStart(builder, node);
                WriteCreateAssignment(builder, node, $"_c{Deref}CreateViewBox()");
                InitializeCompositionObject(builder, obj, node);
                builder.WriteLine($"result.Size = {Vector2(obj.Size)};");
                StartAnimations(builder, obj, node);
                WriteObjectFactoryEnd(builder);
                return true;
            }

            bool GenerateCompositionVisualSurfaceFactory(CodeBuilder builder, CompositionVisualSurface obj, ObjectData node)
            {
                WriteObjectFactoryStart(builder, node);
                WriteCreateAssignment(builder, node, $"_c{Deref}CreateVisualSurface()");
                InitializeCompositionObject(builder, obj, node);

                if (obj.SourceVisual != null)
                {
                    builder.WriteLine($"result{Deref}SourceVisual = {CallFactoryFromFor(node, obj.SourceVisual)};");
                }

                if (obj.SourceSize != null)
                {
                    builder.WriteLine($"result{Deref}SourceSize = {Vector2(obj.SourceSize.Value)};");
                }

                if (obj.SourceOffset != null)
                {
                    builder.WriteLine($"result{Deref}SourceOffset = {Vector2(obj.SourceOffset.Value)};");
                }

                StartAnimations(builder, obj, node);
                WriteObjectFactoryEnd(builder);
                return true;
            }

            void WriteCreateAssignment(CodeBuilder builder, ObjectData node, string createCallText)
            {
                if (node.RequiresStorage)
                {
                    if (_owner._disableFieldOptimization)
                    {
                        // If the field has already been assigned, return its value.
                        builder.WriteLine($"if ({node.FieldName} != {Null}) {{ return {node.FieldName}; }}");
                    }

                    builder.WriteLine($"{Var} result = {node.FieldName} = {createCallText};");
                }
                else
                {
                    builder.WriteLine($"{Var} result = {createCallText};");
                }
            }

            // Handles object factories that are just a create call.
            void WriteSimpleObjectFactory(CodeBuilder builder, ObjectData node, string createCallText)
            {
                builder.WriteComment(node.LongComment);
                WriteObjectFactoryStartWithoutCache(builder, node);
                if (node.RequiresStorage)
                {
                    builder.WriteLine($"return {node.FieldName} = {createCallText};");
                }
                else
                {
                    builder.WriteLine($"return {createCallText};");
                }

                builder.CloseScope();
                builder.WriteLine();
            }

            IAnimatedVisualSourceInfo IAnimatedVisualInfo.AnimatedVisualSourceInfo => _owner;

            string IAnimatedVisualInfo.ClassName => $"AnimatedVisual_UAPv{_requiredUapVersion}";

            IReadOnlyList<LoadedImageSurfaceInfo> IAnimatedVisualInfo.LoadedImageSurfaceNodes => GetLoadedImageSurfaceInfos().ToArray();

            uint IAnimatedVisualInfo.RequiredUapVersion => _requiredUapVersion;
        }

        // Aggregates ObjectData nodes that are shared between different IAnimatedVisual instances,
        // for example, LoadedImageSurface objects. Such nodes describe factories that are
        // scoped to the IAnimatedVisualSource implementation rather than the IAnimatedVisual implementation.
        sealed class SharedNodeGroup
        {
            readonly ObjectData[] _items;

            internal SharedNodeGroup(IEnumerable<ObjectData> items)
            {
                _items = items.ToArray();
            }

            /// <summary>
            /// An <see cref="ObjectData"/> object that will be treated as the canonical object.
            /// </summary>
            internal ObjectData CanonicalNode => _items[0];

            /// <summary>
            /// The <see cref="ObjectData"/> objects except the <see cref="CanonicalNode"/> object.
            /// </summary>
            internal IEnumerable<ObjectData> Rest => _items.Skip(1);

            /// <summary>
            ///  All of the <see cref="ObjectData"/> objects that are sharing this group.
            /// </summary>
            internal IReadOnlyList<ObjectData> All => _items;
        }

        // A node in the object graph, annotated with extra stuff to assist in code generation.
        sealed class ObjectData : Graph.Node<ObjectData>
        {
            string _overriddenFactoryCall;
            Dictionary<ObjectData, string> _callFactoryFromForCache;

            public Dictionary<ObjectData, string> CallFactoryFromForCache
            {
                get
                {
                    // Lazy initialization because not all nodes need the cache.
                    if (_callFactoryFromForCache == null)
                    {
                        _callFactoryFromForCache = new Dictionary<ObjectData, string>();
                    }

                    return _callFactoryFromForCache;
                }
            }

            // The name that is given to the node by the NodeNamer. This name is used to generate factory method
            // names and field names.
            public string Name { get; set; }

            public string FieldName => RequiresStorage ? CamelCase(Name) : null;

            // Returns text for obtaining the value for this node. If the node has
            // been inlined, this can generate the code into the returned string, otherwise
            // it returns code for calling the factory.
            internal string FactoryCall()
            {
                if (Inlined)
                {
                    return _overriddenFactoryCall;
                }
                else
                {
                    return $"{Name}()";
                }
            }

            IEnumerable<string> GetAncestorShortComments()
            {
                // Get the nodes that reference this node.
                var parents = InReferences.Select(v => v.Node).ToArray();
                if (parents.Length == 1)
                {
                    // There is exactly one parent.
                    if (string.IsNullOrWhiteSpace(parents[0].ShortComment))
                    {
                        // Parent has no comment.
                        yield break;
                    }

                    foreach (var ancestorShortcomment in parents[0].GetAncestorShortComments())
                    {
                        yield return ancestorShortcomment;
                    }

                    yield return parents[0].ShortComment;
                }
            }

            internal string LongComment
            {
                get
                {
                    // Prepend the ancestor nodes.
                    var sb = new StringBuilder();
                    var ancestorIndent = 0;
                    foreach (var ancestorComment in GetAncestorShortComments())
                    {
                        sb.Append(new string(' ', ancestorIndent));
                        sb.AppendLine(ancestorComment);
                        ancestorIndent += 2;
                    }

                    sb.Append(((IDescribable)Object).LongDescription);

                    return sb.ToString();
                }
            }

            internal string ShortComment => ((IDescribable)Object).ShortDescription;

            // True if the object is referenced from more than one method and
            // therefore must be stored after it is created.
            internal bool RequiresStorage { get; set; }

            // True if the object must be stored as read-only after it is created.
            internal bool RequiresReadonlyStorage { get; set; }

            // Set to indicate that the node relies on Microsoft.Graphics.Canvas namespace
            internal bool UsesCanvas => Object is CompositionEffectBrush;

            // Set to indicate that the node relies on Microsoft.Graphics.Canvas.Effects namespace
            internal bool UsesCanvasEffects => Object is CompositionEffectBrush;

            // Set to indicate that the node relies on Microsoft.Graphics.Canvas.Geometry namespace
            internal bool UsesCanvasGeometry => Object is CanvasGeometry;

            // Set to indicate that the node is a LoadedImageSurface.
            internal bool IsLoadedImageSurface => Object is Wmd.LoadedImageSurface;

            // True if the node describes an object that can be shared between
            // multiple IAnimatedVisual classes, and thus will be associated with the
            // IAnimatedVisualSource implementation rather than the IAnimatedVisual implementation.
            internal bool IsShareableNode => IsLoadedImageSurface;

            // Set to indicate that the node uses the Windows.UI.Xaml.Media namespace.
            internal bool UsesNamespaceWindowsUIXamlMedia => IsLoadedImageSurface;

            // Set to indicate that the node uses stream(s).
            internal bool UsesStream => Object is Wmd.LoadedImageSurface lis && lis.Type == Wmd.LoadedImageSurface.LoadedImageSurfaceType.FromStream;

            // Set to indicate that the node uses asset file(s).
            internal bool UsesAssetFile => Object is Wmd.LoadedImageSurface lis && lis.Type == Wmd.LoadedImageSurface.LoadedImageSurfaceType.FromUri;

            // Set to indicate that the composition depends on a composite effect.
            internal bool UsesCompositeEffect => Object is CompositionEffectBrush compositeEffectBrush && compositeEffectBrush.GetEffect().Type == Mgce.GraphicsEffectType.CompositeEffect;

            // Identifies the byte array of a LoadedImageSurface.
            internal string LoadedImageSurfaceBytesFieldName => $"s_{Name}_Bytes";

            internal Uri LoadedImageSurfaceImageUri { get; set; }

            // True if the code to create the object will be generated inline.
            internal bool Inlined => _overriddenFactoryCall != null;

            internal void ForceInline(string replacementFactoryCall)
            {
                _overriddenFactoryCall = replacementFactoryCall;
            }

            // The name of the type of the object described by this node.
            // This is the name used as the return type of a factory method.
            internal string TypeName
            {
                get
                {
                    switch (Type)
                    {
                        case Graph.NodeType.CompositionObject:
                            return ((CompositionObject)Object).Type.ToString();
                        case Graph.NodeType.CompositionPath:
                            return "CompositionPath";
                        case Graph.NodeType.CanvasGeometry:
                            return "CanvasGeometry";
                        case Graph.NodeType.LoadedImageSurface:
                            return "LoadedImageSurface";
                        default:
                            throw new InvalidOperationException();
                    }
                }
            }

            // For debugging purposes only.
            public override string ToString() => Name == null ? $"{TypeName} {InReferences.Length}" : $"{Name} {InReferences.Length}";

            // Sets the first character to lower case.
            static string CamelCase(string value) => $"_{char.ToLowerInvariant(value[0])}{value.Substring(1)}";
        }
    }
}
