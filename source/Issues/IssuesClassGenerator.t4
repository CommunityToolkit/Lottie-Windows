<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ output extension=".cs" encoding="utf-8" #>
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;

namespace <#=namespaceName#>
{
    /// <summary>
    /// Issues.
    /// </summary>
    sealed class <#=className#>
    {
        readonly HashSet<(string Code, string Description)> _issues = new HashSet<(string Code, string Description)>();
        readonly bool _throwOnIssue;

        internal <#=className#>(bool throwOnIssue)
        {
            _throwOnIssue = throwOnIssue;
        }

        internal (string Code, string Description)[] GetIssues() => _issues.ToArray();
<#  
    var regex = new Regex("({.*?})");

    // Get the .md files with the prefix matching the type of issues class being generated.
    var mdFiles = Directory.EnumerateFiles(".", $"{prefixFilter}????.md").ToArray();

    foreach (var mdFile in mdFiles)
    {
        // The issue id is the name of the file without the extension.
        var issueId = Path.GetFileNameWithoutExtension(mdFile);

        // Read the file.
        const string commentPrefix = "[comment]: # (";
        var mdCommentLines = 
            (from line in File.ReadAllLines(mdFile)
            where line.StartsWith(commentPrefix)
            select line.Substring(commentPrefix.Length).TrimEnd(')')).ToArray();

        const string namePrefix = "name:";
        const string textPrefix = "text:";

        var name = 
            (from line in mdCommentLines
            where line.StartsWith(namePrefix)
            select line.Substring(namePrefix.Length)).FirstOrDefault();

        var text = 
            (from line in mdCommentLines
            where line.StartsWith(textPrefix)
            select line.Substring(textPrefix.Length)).FirstOrDefault();

        // Escape double-quotes.
        text = text.Replace("\"", "\\\"");

        // Look for parameters in the string.
        var parameterMatches = regex.Matches(text);

        // Create parameters for each of the parameters in the text.
        var parameters = regex.Matches(text).Cast<Match>().Select(m => $"string {m.Value.Substring(1, m.Value.Length - 2)}").Distinct().ToArray();
        var parameterList = string.Join(", ", parameters);
        var hasParameters = parameters.Any();

        WriteLine("");
        WriteLine($"        internal void {name}({parameterList}) => Report(\"{issueId}\", {(hasParameters ? "$" : "")}\"{text}\");");
    }
#>

        void Report(string code, string description)
        {
            _issues.Add((code, description));

            if (_throwOnIssue)
            {
                throw new NotSupportedException($"{code}: {description}");
            }
        }
    }
}