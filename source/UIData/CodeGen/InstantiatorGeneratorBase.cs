// Copyright(c) Microsoft Corporation.All rights reserved.
// Licensed under the MIT License.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Numerics;
using System.Text;
using Microsoft.Toolkit.Uwp.UI.Lottie.UIData.Tools;
using Microsoft.Toolkit.Uwp.UI.Lottie.WinCompData;
using Microsoft.Toolkit.Uwp.UI.Lottie.WinCompData.Mgc;
using Microsoft.Toolkit.Uwp.UI.Lottie.WinCompData.Mgcg;
using Microsoft.Toolkit.Uwp.UI.Lottie.WinCompData.Wui;
using Mgce = Microsoft.Toolkit.Uwp.UI.Lottie.WinCompData.Mgce;
using Wg = Microsoft.Toolkit.Uwp.UI.Lottie.WinCompData.Wg;
using Wmd = Microsoft.Toolkit.Uwp.UI.Lottie.WinUIXamlMediaData;

namespace Microsoft.Toolkit.Uwp.UI.Lottie.UIData.CodeGen
{
#if PUBLIC_UIData
    public
#endif
    abstract class InstantiatorGeneratorBase
    {
        // The name of the field holding the singleton reusable ExpressionAnimation.
        const string SingletonExpressionAnimationName = "_reusableExpressionAnimation";
        const string DurationTicksFieldName = "c_durationTicks";
        static readonly string[] _autoGeneratedHeaderText = new string[]
        {
            "//------------------------------------------------------------------------------",
            "// <auto-generated>",
            "//     This code was generated by a tool.",
            "//",
            "//     Changes to this file may cause incorrect behavior and will be lost if",
            "//     the code is regenerated.",
            "// </auto-generated>",
            "//------------------------------------------------------------------------------",
        };

        readonly bool _setCommentProperties;
        readonly bool _disableFieldOptimization;
        readonly ObjectGraph<ObjectData> _objectGraph;

        // The subset of the object graph for which nodes will be generated.
        readonly ObjectData[] _nodes;
        readonly IStringifier _stringifier;
        readonly HashSet<(ObjectData, ObjectData)> _factoriesAlreadyCalled = new HashSet<(ObjectData, ObjectData)>();
        readonly ObjectData _rootNode;
        readonly ApiCompatibility _apiCompatibility;
        readonly TimeSpan _compositionDuration;

        // Holds the node for which a factory is currently being written.
        ObjectData _currentObjectFactoryNode;

        protected InstantiatorGeneratorBase(
            string className,
            CompositionObject graphRoot,
            TimeSpan duration,
            bool setCommentProperties,
            bool disableFieldOptimization,
            IStringifier stringifier)
        {
            _compositionDuration = duration;
            _setCommentProperties = setCommentProperties;
            _disableFieldOptimization = disableFieldOptimization;
            _stringifier = stringifier;

            // Get the API compatibility information.
            _apiCompatibility = ApiCompatibility.Analyze(graphRoot);

            // Build the object graph.
            _objectGraph = ObjectGraph<ObjectData>.FromCompositionObject(graphRoot, includeVertices: true);

            // Filter out ExpressionAnimations that are unique. They will use a single instance that is reset on each use.
            // TODO - should look at the distinct inrefs - i.e. how many objects are referencing, to deal with objects that reference multiple times.
            var nodes =
                from node in _objectGraph.Nodes
                where !(node.Object is ExpressionAnimation) ||
                        node.InReferences.Length > 1
                select node;

            // Filter out types for which we won't create objects:
            //  AnimationController is created implicitly.
            //  CompositionPropertySet is created implicitly.
            nodes =
                (from node in nodes
                 where node.Type != Graph.NodeType.CompositionObject ||
                     !(((CompositionObject)node.Object).Type == CompositionObjectType.AnimationController ||
                      ((CompositionObject)node.Object).Type == CompositionObjectType.CompositionPropertySet)
                 select node).Distinct().ToArray();

            // Give names to each node.
            foreach ((var n, var name) in NodeNamer<ObjectData>.GenerateNodeNames(nodes))
            {
                n.Name = name;
            }

            // Give the root node a special name.
            _rootNode = NodeFor(graphRoot);
            _rootNode.Name = "Root";

            // Save the nodes, ordered by the name that was just set.
            _nodes = nodes.OrderBy(node => node.Name).ToArray();

            // Force storage to be allocated for nodes that have multiple references to them,
            // or is a LoadedImageSurface.
            foreach (var node in _nodes)
            {
                if (FilteredInRefs(node).Count() > 1 || node.IsLoadedImageSurface)
                {
                    // Node is referenced more than once or a LoadedImageSurface, so it requires storage.
                    node.RequiresStorage = true;

                    if (node.IsLoadedImageSurface)
                    {
                        // Node is a LoadedImageSurface which requires read-only storage.
                        node.RequiresReadonlyStorage = true;
                    }
                }
            }

            // Force inlining on CompositionPath nodes that are only referenced once, because they are always very simple.
            foreach (var node in _nodes)
            {
                if (node.Type == Graph.NodeType.CompositionPath && FilteredInRefs(node).Count() == 1)
                {
                    node.RequiresStorage = false;
                    var pathSourceFactoryCall = CallFactoryFromFor(node, ((CompositionPath)node.Object).Source);
                    node.ForceInline($"{New} CompositionPath({_stringifier.FactoryCall(pathSourceFactoryCall)})");
                }
            }

            // Ensure the root object has storage if it is referenced by anything else in the graph.
            // This is necessary because the root node is referenced from the instantiator entrypoint
            // but that isn't counted in the InReference.
            if (_rootNode.InReferences.Any())
            {
                _rootNode.RequiresStorage = true;
            }

            // Set the Uri of the image file for LoadedImageSurfaceFromUri to $"ms-appx:///Assets/<className>/<filePath>/<fileName>.
            foreach (var node in _nodes.Where(n => n.UsesAssetFile))
            {
                var loadedImageSurfaceObj = (Wmd.LoadedImageSurfaceFromUri)node.Object;
                var imageUri = loadedImageSurfaceObj.Uri;

                if (imageUri.IsFile)
                {
                    node.LoadedImageSurfaceImageUri = new Uri($"ms-appx:///Assets/{className}{imageUri.AbsolutePath}");
                }
            }
        }

        /// <summary>
        /// Takes a name and modifies it as necessary to be suited for use as a class name in languages such
        /// as  C# and C++.
        /// Returns null on failure.
        /// </summary>
        /// <returns>A name, or null.</returns>
        public static string TrySynthesizeClassName(string name)
        {
            if (string.IsNullOrWhiteSpace(name))
            {
                return null;
            }

            // Remove any non-characters from the start of the name.
            var nonCharPrefixSize = name.TakeWhile(c => !char.IsLetter(c)).Count();
            return SanitizeTypeName(name.Substring(nonCharPrefixSize));
        }

        // Makes the given name suitable for use as a class name in languages such as C# and C++.
        static string SanitizeTypeName(string name)
        {
            if (string.IsNullOrWhiteSpace(name))
            {
                return null;
            }

            // If the first character is not a letter, prepend an underscore.
            if (!char.IsLetter(name, 0))
            {
                name = "_" + name;
            }

            // Replace any disallowed character with underscores.
            name =
                new string((from ch in name
                            select char.IsLetterOrDigit(ch) ? ch : '_').ToArray());

            // Remove any duplicated underscores.
            name = name.Replace("__", "_");

            // Capitalize the first letter.
            name = name.ToUpperInvariant().Substring(0, 1) + name.Substring(1);

            return name;
        }

        /// <summary>
        /// Gets the standard header text used to indicate that a file contains auto-generated content.
        /// </summary>
        protected static IEnumerable<string> AutoGeneratedHeaderText => _autoGeneratedHeaderText;

        /// <summary>
        /// Writes the start of the file, e.g. using namespace statements and includes at the top of the file.
        /// </summary>
        protected abstract void WriteFileStart(
            CodeBuilder builder,
            CodeGenInfo info);

        /// <summary>
        /// Writes the start of the Instantiator class.
        /// </summary>
        protected abstract void WriteInstantiatorStart(
            CodeBuilder builder,
            CodeGenInfo info);

        /// <summary>
        /// Writes the end of the class.
        /// </summary>
        protected abstract void WriteFileEnd(
            CodeBuilder builder,
            CodeGenInfo info);

        /// <summary>
        /// Writes CanvasGeometery.Combination factory code.
        /// </summary>
        /// <param name="builder">A <see cref="CodeBuilder"/> used to create the code.</param>
        /// <param name="obj">Describes the object that should be instantiated by the factory code.</param>
        /// <param name="typeName">The type of the result.</param>
        /// <param name="fieldName">If not null, the name of the field in which the result is stored.</param>
        protected abstract void WriteCanvasGeometryCombinationFactory(
            CodeBuilder builder,
            CanvasGeometry.Combination obj,
            string typeName,
            string fieldName);

        /// <summary>
        /// Writes CanvasGeometery.Ellipse factory code.
        /// </summary>
        /// <param name="builder">A <see cref="CodeBuilder"/> used to create the code.</param>
        /// <param name="obj">Describes the object that should be instantiated by the factory code.</param>
        /// <param name="typeName">The type of the result.</param>
        /// <param name="fieldName">If not null, the name of the field in which the result is stored.</param>
        protected abstract void WriteCanvasGeometryEllipseFactory(
            CodeBuilder builder,
            CanvasGeometry.Ellipse obj,
            string typeName,
            string fieldName);

        /// <summary>
        /// Writes CanvasGeometery.Ellipse factory code.
        /// </summary>
        /// <param name="builder">A <see cref="CodeBuilder"/> used to create the code.</param>
        /// <param name="obj">Describes the object that should be instantiated by the factory code.</param>
        /// <param name="typeName">The type of the result.</param>
        /// <param name="fieldName">If not null, the name of the field in which the result is stored.</param>
        protected abstract void WriteCanvasGeometryGroupFactory(
            CodeBuilder builder,
            CanvasGeometry.Group obj,
            string typeName,
            string fieldName);

        /// <summary>
        /// Writes CanvasGeometery.Path factory code.
        /// </summary>
        /// <param name="builder">A <see cref="CodeBuilder"/> used to create the code.</param>
        /// <param name="obj">Describes the object that should be instantiated by the factory code.</param>
        /// <param name="typeName">The type of the result.</param>
        /// <param name="fieldName">If not null, the name of the field in which the result is stored.</param>
        protected abstract void WriteCanvasGeometryPathFactory(
            CodeBuilder builder,
            CanvasGeometry.Path obj,
            string typeName,
            string fieldName);

        /// <summary>
        /// Writes CanvasGeometery.RoundedRectangle factory code.
        /// </summary>
        /// <param name="builder">A <see cref="CodeBuilder"/> used to create the code.</param>
        /// <param name="obj">Describes the object that should be instantiated by the factory code.</param>
        /// <param name="typeName">The type of the result.</param>
        /// <param name="fieldName">If not null, the name of the field in which the result is stored.</param>
        protected abstract void WriteCanvasGeometryRoundedRectangleFactory(
            CodeBuilder builder,
            CanvasGeometry.RoundedRectangle obj,
            string typeName,
            string fieldName);

        /// <summary>
        /// Writes CanvasGeometery.TransformedGeometry factory code.
        /// </summary>
        /// <param name="builder">A <see cref="CodeBuilder"/> used to create the code.</param>
        /// <param name="obj">Describes the object that should be instantiated by the factory code.</param>
        /// <param name="typeName">The type of the result.</param>
        /// <param name="fieldName">If not null, the name of the field in which the result is stored.</param>
        protected abstract void WriteCanvasGeometryTransformedGeometryFactory(
            CodeBuilder builder,
            CanvasGeometry.TransformedGeometry obj,
            string typeName,
            string fieldName);

        /// <summary>
        /// Write the CompositeEffect factory code.
        /// </summary>
        /// <param name="builder">A <see cref="CodeBuilder"/> used to create the code.</param>
        /// <param name="compositeEffect">Composite effect object.</param>
        /// <returns>String that should be used as the parameter for CreateEffectFactory.</returns>
        protected abstract string WriteCompositeEffectFactory(
            CodeBuilder builder,
            Mgce.CompositeEffect compositeEffect);

        /// <summary>
        /// Write a Bytes field.
        /// </summary>
        /// <param name="builder">A <see cref="CodeBuilder"/> used to create the code.</param>
        /// <param name="fieldName">The name of the Bytes field to be written.</param>
        protected void WriteBytesField(CodeBuilder builder, string fieldName)
        {
            builder.WriteLine($"{_stringifier.Static} {_stringifier.Readonly(_stringifier.ReferenceTypeName(_stringifier.ByteArray))} {fieldName} = {_stringifier.New} {_stringifier.ByteArray}");
        }

        /// <summary>
        /// Call this to get a list of the asset files referenced by the generated code.
        /// </summary>
        /// <returns>
        /// List of asset files and their relative path to the Asset folder in a UWP that are referenced by the generated code.
        /// An item in the returned list has format "ms-appx:///Assets/subFolder/fileName", which the generated code
        /// will use to load the file from.
        /// </returns>
        protected IEnumerable<Uri> GetAssetsList()
        {
            return _nodes.Where(n => n.UsesAssetFile).Select(n => n.LoadedImageSurfaceImageUri).Distinct();
        }

        /// <summary>
        /// Gets a list of the <see cref="LoadedImageSurfaceNode"/> representing the LoadedImageSurface of the composition and its properties.
        /// </summary>
        /// <returns>List of the <see cref="LoadedImageSurfaceNode"/> representing the LoadedImageSurface and its properties.</returns>
        protected IEnumerable<LoadedImageSurfaceNode> GetLoadedImageSurfacesNodes()
        {
            return
                from n in _nodes
                where n.IsLoadedImageSurface
                select new LoadedImageSurfaceNode(
                                n.TypeName,
                                n.Name,
                                n.FieldName,
                                n.LoadedImageSurfaceBytesFieldName,
                                n.LoadedImageSurfaceImageUri,
                                ((Wmd.LoadedImageSurface)n.Object).Type);
        }

        /// <summary>
        /// Call this to generate the code. Returns a string containing the generated code.
        /// </summary>
        /// <returns>The code.</returns>
        protected string GenerateCode(
            string className,
            float width,
            float height)
        {
            var builder = new CodeBuilder();

            var info = new CodeGenInfo(
                className: className,
                reusableExpressionAnimationFieldName: SingletonExpressionAnimationName,
                durationTicksFieldName: DurationTicksFieldName,
                compositionDeclaredSize: new Vector2(width, height),
                rootVisual: (Visual)_rootNode.Object,
                usesCanvas: _nodes.Where(n => n.UsesCanvas).Any(),
                usesCanvasEffects: _nodes.Where(n => n.UsesCanvasEffects).Any(),
                usesCanvasGeometry: _nodes.Where(n => n.UsesCanvasGeometry).Any(),
                usesNamespaceWindowsUIXamlMedia: _nodes.Where(n => n.UsesNamespaceWindowsUIXamlMedia).Any(),
                usesStreams: _nodes.Where(n => n.UsesStream).Any(),
                hasLoadedImageSurface: _nodes.Where(n => n.IsLoadedImageSurface).Any(),
                loadedImageSurfaceNodes: GetLoadedImageSurfacesNodes(),
                usesCompositeEffect: _nodes.Where(n => n.UsesCompositeEffect).Any()
                );

            // Write the auto-generated warning comment.
            foreach (var line in _autoGeneratedHeaderText)
            {
                builder.WriteLine(line);
            }

            // Get the derived class to write the start of the file. This is everything
            // up to the start of the Instantiator class.
            WriteFileStart(builder, info);

            // Write the LoadedImageSurface byte arrays.
            WriteBytesFields(builder);

            // Write the IsRuntimeCompatible() method.
            WriteIsRuntimeCompatibleMethod(builder);

            // Write the body of the Instantiator class.
            WriteInstantiatorStart(builder, info);

            // Write fields for constant values.
            WriteField(builder, Const(_stringifier.Int64TypeName), $"{DurationTicksFieldName} = {_stringifier.Int64(_compositionDuration.Ticks)}");

            // Write fields for each object that needs storage (i.e. objects that are
            // referenced more than once).
            // Write read-only fields first.
            WriteField(builder, Readonly(_stringifier.ReferenceTypeName("Compositor")), "_c");
            WriteField(builder, Readonly(_stringifier.ReferenceTypeName("ExpressionAnimation")), SingletonExpressionAnimationName);

            foreach (var node in _nodes.Where(n => n.RequiresReadonlyStorage))
            {
                // Generate a field for the read-only storage.
                WriteField(builder, Readonly(_stringifier.ReferenceTypeName(node.TypeName)), node.FieldName);
            }

            foreach (var node in _nodes.Where(n => n.RequiresStorage && !n.RequiresReadonlyStorage))
            {
                // Generate a field for the storage.
                WriteField(builder, _stringifier.ReferenceTypeName(node.TypeName), node.FieldName);
            }

            builder.WriteLine();

            // Write methods for each node.
            foreach (var node in _nodes)
            {
                WriteCodeForNode(builder, info, node);
            }

            // Write the end of the Instantiator class and the end of the file.
            WriteFileEnd(builder, info);

            return builder.ToString();
        }

        /// <summary>
        /// Returns the code to call the factory for the given object.
        /// </summary>
        /// <returns>The code to call the factory for the given object.</returns>
        protected string CallFactoryFor(CanvasGeometry obj)
        {
            return CallFactoryFromFor(_currentObjectFactoryNode, obj);
        }

        // Returns the code to call the factory for the given node from the given node.
        string CallFactoryFromFor(ObjectData callerNode, ObjectData calleeNode)
        {
            if (callerNode.CallFactoryFromForCache.TryGetValue(calleeNode, out string result))
            {
                // Return the factory from the cache.
                return result;
            }

            // Get the factory call code.
            result = CallFactoryFromFor_UnCached(callerNode, calleeNode);

            // Save the factory call code in the cache on the caller for next time.
            if (calleeNode.RequiresStorage && !_disableFieldOptimization)
            {
                // The node has storage for its result. Next time just return the field.
                callerNode.CallFactoryFromForCache.Add(calleeNode, calleeNode.FieldName);
            }
            else
            {
                callerNode.CallFactoryFromForCache.Add(calleeNode, result);
            }

            return result;
        }

        // Returns the code to call the factory for the given node from the given node.
        string CallFactoryFromFor_UnCached(ObjectData callerNode, ObjectData calleeNode)
        {
            // Calling into the root node is handled specially. The root node is always
            // created before the first vertex to it, so it is sufficient to just get
            // it from its field.
            if (calleeNode == _rootNode)
            {
                Debug.Assert(calleeNode.RequiresStorage, "Root node is not stored in a field");
                return calleeNode.FieldName;
            }

            if (_disableFieldOptimization)
            {
                // When field optimization is disabled, always return a call to the factory.
                // If the factory has been called already, it will return the value from
                // its storage.
                return calleeNode.FactoryCall();
            }

            // Find the vertex from caller to callee.
            var firstVertexFromCallerToCallee =
                    (from inref in calleeNode.InReferences
                     where inref.Node == callerNode
                     orderby inref.Position
                     select inref).First();

            // Find the first vertex to the callee from any caller.
            var firstVertexToCallee = calleeNode.InReferences.First();

            // If the object has a vertex with a lower position then the object
            // will have already been created by the time the caller needs the object.
            if (firstVertexToCallee.Position < firstVertexFromCallerToCallee.Position)
            {
                // The object was created by another caller. Just access the field.
                Debug.Assert(calleeNode.RequiresStorage, "Expecting to access a field containing a previously cached value, but the callee has no field");
                return calleeNode.FieldName;
            }
            else if (calleeNode.RequiresStorage && _factoriesAlreadyCalled.Contains((callerNode, calleeNode)))
            {
                return calleeNode.FieldName;
            }
            else
            {
                // Keep track of the fact that the caller called the factory
                // already. If the caller asks for the factory twice and the factory
                // does not have a cache, then the caller was expected to store the
                // result in a local.
                // NOTE: currently there is no generated code that is known to hit this case,
                // so this is just here to ensure we find it if it happens.
                if (!_factoriesAlreadyCalled.Add((callerNode, calleeNode)))
                {
                    throw new InvalidOperationException();
                }

                return calleeNode.FactoryCall();
            }
        }

        // Returns the code to call the factory for the given object from the given node.
        string CallFactoryFromFor(ObjectData callerNode, CompositionObject obj) => CallFactoryFromFor(callerNode, NodeFor(obj));

        string CallFactoryFromFor(ObjectData callerNode, CompositionPath obj) => CallFactoryFromFor(callerNode, NodeFor(obj));

        string CallFactoryFromFor(ObjectData callerNode, Wg.IGeometrySource2D obj) => CallFactoryFromFor(callerNode, NodeFor(obj));

        string CallFactoryFromFor(ObjectData callerNode, Wmd.LoadedImageSurface obj) => CallFactoryFromFor(callerNode, NodeFor(obj));

        // Returns the node for the given object.
        ObjectData NodeFor(CompositionObject obj) => _objectGraph[obj];

        ObjectData NodeFor(CompositionPath obj) => _objectGraph[obj];

        ObjectData NodeFor(Wg.IGeometrySource2D obj) => _objectGraph[obj];

        ObjectData NodeFor(Wmd.LoadedImageSurface obj) => _objectGraph[obj];

        // Gets the InReferences for node, ignoring those from ExpressionAnimations
        // that have a single instance because they are treated specially (they are initialized inline).
        IEnumerable<ObjectData> FilteredInRefs(ObjectData node)
        {
            // Examine all of the inrefs to the node.
            foreach (var vertex in node.InReferences)
            {
                var item = vertex.Node;

                // If the inref is from an ExpressionAnimation ...
                if (item.Object is ExpressionAnimation exprAnim)
                {
                    // ... is the animation shared?
                    if (item.InReferences.Length > 1)
                    {
                        yield return item;
                        continue;
                    }

                    // ... is the animation animating a property on the current node or its property set.
                    bool isExpressionOnThisNode = false;

                    var compObject = node.Object as CompositionObject;

                    // Search the animators to find the animator for this ExpressionAnimation.
                    // It will be found iff the ExpressionAnimation is animating this node.
                    foreach (var animator in compObject.Animators.Concat(compObject.Properties.Animators))
                    {
                        if (animator.Animation is ExpressionAnimation animatorExpression &&
                            animatorExpression.Expression == exprAnim.Expression)
                        {
                            isExpressionOnThisNode = true;
                            break;
                        }
                    }

                    if (!isExpressionOnThisNode)
                    {
                        yield return item;
                    }
                }
                else
                {
                    yield return item;
                }
            }
        }

        void WriteIsRuntimeCompatibleMethod(CodeBuilder builder)
        {
            // Write the RuntimeCompatibility() method.
            builder.WriteLine("static bool IsRuntimeCompatible()");
            builder.OpenScope();
            builder.WriteLine($"if (!Windows{_stringifier.ScopeResolve}Foundation{_stringifier.ScopeResolve}Metadata{_stringifier.ScopeResolve}ApiInformation{_stringifier.ScopeResolve}IsTypePresent(\"Windows.UI.Composition.CompositionGeometricClip\"))");
            builder.OpenScope();
            builder.WriteLine("return false;");
            builder.CloseScope();

            if (_apiCompatibility.RequiresCompositionVisualSurface)
            {
                builder.WriteLine($"if (!Windows{_stringifier.ScopeResolve}Foundation{_stringifier.ScopeResolve}Metadata{_stringifier.ScopeResolve}ApiInformation{_stringifier.ScopeResolve}IsTypePresent(\"Windows.UI.Composition.CompositionVisualSurface\"))");
                builder.OpenScope();
                builder.WriteLine("return false;");
                builder.CloseScope();
            }

            builder.WriteLine("return true;");
            builder.CloseScope();
            builder.WriteLine();
        }

        void WriteField(CodeBuilder builder, string typeName, string fieldName)
        {
            builder.WriteLine($"{typeName} {fieldName};");
        }

        void WriteBytesFields(CodeBuilder builder)
        {
            bool bytesWritten = false;

            foreach (var node in _nodes.Where(n => n.UsesStream))
            {
                WriteBytesField(builder, node.LoadedImageSurfaceBytesFieldName);
                builder.OpenScope();
                var loadedImageSurface = (Wmd.LoadedImageSurfaceFromStream)node.Object;
                builder.BytesToLiteral(loadedImageSurface.Bytes, maximumColumns: 100);
                builder.UnIndent();
                builder.WriteLine("};");
                bytesWritten = true;
            }

            if (bytesWritten)
            {
                builder.WriteLine();
            }
        }

        // Generates code for the given node. The code is written into the CodeBuilder on the node.
        void WriteCodeForNode(CodeBuilder builder, CodeGenInfo info, ObjectData node)
        {
            // Only generate if the node is not inlined into the caller.
            if (!node.Inlined)
            {
                switch (node.Type)
                {
                    case Graph.NodeType.CompositionObject:
                        GenerateObjectFactory(builder, (CompositionObject)node.Object, node);
                        break;
                    case Graph.NodeType.CompositionPath:
                        GenerateCompositionPathFactory(builder, (CompositionPath)node.Object, node);
                        break;
                    case Graph.NodeType.CanvasGeometry:
                        GenerateCanvasGeometryFactory(builder, (CanvasGeometry)node.Object, node);
                        break;
                    case Graph.NodeType.LoadedImageSurface:
                        // LoadedImageSurface is written out in the IDynamicAnimatedVisualSource class, so does not need to do anything here.
                        break;
                    default:
                        throw new InvalidOperationException();
                }
            }
        }

        bool GenerateCanvasGeometryFactory(CodeBuilder builder, CanvasGeometry obj, ObjectData node)
        {
            WriteObjectFactoryStart(builder, node);
            var typeName = _stringifier.ReferenceTypeName(node.TypeName);
            var fieldName = node.FieldName;

            switch (obj.Type)
            {
                case CanvasGeometry.GeometryType.Combination:
                    WriteCanvasGeometryCombinationFactory(builder, (CanvasGeometry.Combination)obj, typeName, fieldName);
                    break;
                case CanvasGeometry.GeometryType.Ellipse:
                    WriteCanvasGeometryEllipseFactory(builder, (CanvasGeometry.Ellipse)obj, typeName, fieldName);
                    break;
                case CanvasGeometry.GeometryType.Group:
                    WriteCanvasGeometryGroupFactory(builder, (CanvasGeometry.Group)obj, typeName, fieldName);
                    break;
                case CanvasGeometry.GeometryType.Path:
                    WriteCanvasGeometryPathFactory(builder, (CanvasGeometry.Path)obj, typeName, fieldName);
                    break;
                case CanvasGeometry.GeometryType.RoundedRectangle:
                    WriteCanvasGeometryRoundedRectangleFactory(builder, (CanvasGeometry.RoundedRectangle)obj, typeName, fieldName);
                    break;
                case CanvasGeometry.GeometryType.TransformedGeometry:
                    WriteCanvasGeometryTransformedGeometryFactory(builder, (CanvasGeometry.TransformedGeometry)obj, typeName, fieldName);
                    break;
                default:
                    throw new InvalidOperationException();
            }

            WriteObjectFactoryEnd(builder);
            return true;
        }

        bool GenerateObjectFactory(CodeBuilder builder, CompositionObject obj, ObjectData node)
        {
            // Uncomment to see the order of creation.
            //builder.WriteComment($"Traversal order: {node.Position}");
            switch (obj.Type)
            {
                case CompositionObjectType.AnimationController:
                    // Do not generate code for animation controllers. It is done inline in the CompositionObject initialization.
                    throw new InvalidOperationException();
                case CompositionObjectType.ColorKeyFrameAnimation:
                    return GenerateColorKeyFrameAnimationFactory(builder, (ColorKeyFrameAnimation)obj, node);
                case CompositionObjectType.CompositionColorBrush:
                    return GenerateCompositionColorBrushFactory(builder, (CompositionColorBrush)obj, node);
                case CompositionObjectType.CompositionColorGradientStop:
                    return GenerateCompositionColorGradientStopFactory(builder, (CompositionColorGradientStop)obj, node);
                case CompositionObjectType.CompositionContainerShape:
                    return GenerateContainerShapeFactory(builder, (CompositionContainerShape)obj, node);
                case CompositionObjectType.CompositionEffectBrush:
                    return GenerateCompositionEffectBrushFactory(builder, (CompositionEffectBrush)obj, node);
                case CompositionObjectType.CompositionEllipseGeometry:
                    return GenerateCompositionEllipseGeometryFactory(builder, (CompositionEllipseGeometry)obj, node);
                case CompositionObjectType.CompositionGeometricClip:
                    return GenerateCompositionGeometricClipFactory(builder, (CompositionGeometricClip)obj, node);
                case CompositionObjectType.CompositionLinearGradientBrush:
                    return GenerateCompositionLinearGradientBrushFactory(builder, (CompositionLinearGradientBrush)obj, node);
                case CompositionObjectType.CompositionPathGeometry:
                    return GenerateCompositionPathGeometryFactory(builder, (CompositionPathGeometry)obj, node);
                case CompositionObjectType.CompositionPropertySet:
                    // Do not generate code for property sets. It is done inline in the CompositionObject initialization.
                    return true;
                case CompositionObjectType.CompositionRadialGradientBrush:
                    return GenerateCompositionRadialGradientBrushFactory(builder, (CompositionRadialGradientBrush)obj, node);
                case CompositionObjectType.CompositionRectangleGeometry:
                    return GenerateCompositionRectangleGeometryFactory(builder, (CompositionRectangleGeometry)obj, node);
                case CompositionObjectType.CompositionRoundedRectangleGeometry:
                    return GenerateCompositionRoundedRectangleGeometryFactory(builder, (CompositionRoundedRectangleGeometry)obj, node);
                case CompositionObjectType.CompositionSpriteShape:
                    return GenerateSpriteShapeFactory(builder, (CompositionSpriteShape)obj, node);
                case CompositionObjectType.CompositionSurfaceBrush:
                    return GenerateCompositionSurfaceBrushFactory(builder, (CompositionSurfaceBrush)obj, node);
                case CompositionObjectType.CompositionViewBox:
                    return GenerateCompositionViewBoxFactory(builder, (CompositionViewBox)obj, node);
                case CompositionObjectType.CompositionVisualSurface:
                    return GenerateCompositionVisualSurfaceFactory(builder, (CompositionVisualSurface)obj, node);
                case CompositionObjectType.ContainerVisual:
                    return GenerateContainerVisualFactory(builder, (ContainerVisual)obj, node);
                case CompositionObjectType.CubicBezierEasingFunction:
                    return GenerateCubicBezierEasingFunctionFactory(builder, (CubicBezierEasingFunction)obj, node);
                case CompositionObjectType.ExpressionAnimation:
                    return GenerateExpressionAnimationFactory(builder, (ExpressionAnimation)obj, node);
                case CompositionObjectType.InsetClip:
                    return GenerateInsetClipFactory(builder, (InsetClip)obj, node);
                case CompositionObjectType.LinearEasingFunction:
                    return GenerateLinearEasingFunctionFactory(builder, (LinearEasingFunction)obj, node);
                case CompositionObjectType.PathKeyFrameAnimation:
                    return GeneratePathKeyFrameAnimationFactory(builder, (PathKeyFrameAnimation)obj, node);
                case CompositionObjectType.ScalarKeyFrameAnimation:
                    return GenerateScalarKeyFrameAnimationFactory(builder, (ScalarKeyFrameAnimation)obj, node);
                case CompositionObjectType.ShapeVisual:
                    return GenerateShapeVisualFactory(builder, (ShapeVisual)obj, node);
                case CompositionObjectType.SpriteVisual:
                    return GenerateSpriteVisualFactory(builder, (SpriteVisual)obj, node);
                case CompositionObjectType.StepEasingFunction:
                    return GenerateStepEasingFunctionFactory(builder, (StepEasingFunction)obj, node);
                case CompositionObjectType.Vector2KeyFrameAnimation:
                    return GenerateVector2KeyFrameAnimationFactory(builder, (Vector2KeyFrameAnimation)obj, node);
                case CompositionObjectType.Vector3KeyFrameAnimation:
                    return GenerateVector3KeyFrameAnimationFactory(builder, (Vector3KeyFrameAnimation)obj, node);
                default:
                    throw new InvalidOperationException();
            }
        }

        bool GenerateInsetClipFactory(CodeBuilder builder, InsetClip obj, ObjectData node)
        {
            WriteObjectFactoryStart(builder, node);
            WriteCreateAssignment(builder, node, $"_c{Deref}CreateInsetClip()");
            InitializeCompositionClip(builder, obj, node);

            if (obj.LeftInset != 0)
            {
                builder.WriteLine($"result{Deref}LeftInset = {Float(obj.LeftInset)}");
            }

            if (obj.RightInset != 0)
            {
                builder.WriteLine($"result{Deref}RightInset = {Float(obj.RightInset)}");
            }

            if (obj.TopInset != 0)
            {
                builder.WriteLine($"result{Deref}TopInset = {Float(obj.TopInset)}");
            }

            if (obj.BottomInset != 0)
            {
                builder.WriteLine($"result{Deref}BottomInset = {Float(obj.BottomInset)}");
            }

            StartAnimations(builder, obj, node);
            WriteObjectFactoryEnd(builder);
            return true;
        }

        bool GenerateCompositionGeometricClipFactory(CodeBuilder builder, CompositionGeometricClip obj, ObjectData node)
        {
            WriteObjectFactoryStart(builder, node);
            WriteCreateAssignment(builder, node, $"_c{Deref}CreateGeometricClip()");
            InitializeCompositionClip(builder, obj, node);

            if (obj.Geometry != null)
            {
                builder.WriteLine($"result{Deref}Geometry = {CallFactoryFromFor(node, obj.Geometry)};");
            }

            StartAnimations(builder, obj, node);
            WriteObjectFactoryEnd(builder);
            return true;
        }

        bool GenerateCompositionLinearGradientBrushFactory(CodeBuilder builder, CompositionLinearGradientBrush obj, ObjectData node)
        {
            WriteObjectFactoryStart(builder, node);
            WriteCreateAssignment(builder, node, $"_c{Deref}CreateLinearGradientBrush()");
            InitializeCompositionGradientBrush(builder, obj, node);

            if (obj.StartPoint.HasValue)
            {
                builder.WriteLine($"result{Deref}StartPoint = {Vector2(obj.StartPoint.Value)};");
            }

            if (obj.EndPoint.HasValue)
            {
                builder.WriteLine($"result{Deref}EndPoint = {Vector2(obj.EndPoint.Value)};");
            }

            StartAnimations(builder, obj, node);
            WriteObjectFactoryEnd(builder);
            return true;
        }

        bool GenerateCompositionRadialGradientBrushFactory(CodeBuilder builder, CompositionRadialGradientBrush obj, ObjectData node)
        {
            throw new NotImplementedException();
        }

        bool GenerateLinearEasingFunctionFactory(CodeBuilder builder, LinearEasingFunction obj, ObjectData node)
        {
            WriteSimpleObjectFactory(builder, node, $"_c{Deref}CreateLinearEasingFunction()");
            return true;
        }

        bool GenerateCubicBezierEasingFunctionFactory(CodeBuilder builder, CubicBezierEasingFunction obj, ObjectData node)
        {
            WriteSimpleObjectFactory(builder, node, $"_c{Deref}CreateCubicBezierEasingFunction({Vector2(obj.ControlPoint1)}, {Vector2(obj.ControlPoint2)})");
            return true;
        }

        bool GenerateStepEasingFunctionFactory(CodeBuilder builder, StepEasingFunction obj, ObjectData node)
        {
            WriteObjectFactoryStart(builder, node);
            WriteCreateAssignment(builder, node, $"_c{Deref}CreateStepEasingFunction()");

            if (obj.FinalStep != 1)
            {
                builder.WriteLine($"result{Deref}FinalStep = {Int(obj.FinalStep)};");
            }

            if (obj.InitialStep != 0)
            {
                builder.WriteLine($"result{Deref}InitialStep = {Int(obj.InitialStep)};");
            }

            if (obj.IsFinalStepSingleFrame)
            {
                builder.WriteLine($"result{Deref}IsFinalStepSingleFrame  = {Bool(obj.IsFinalStepSingleFrame)};");
            }

            if (obj.IsInitialStepSingleFrame)
            {
                builder.WriteLine($"result{Deref}IsInitialStepSingleFrame  = {Bool(obj.IsInitialStepSingleFrame)};");
            }

            if (obj.StepCount != 1)
            {
                builder.WriteLine($"result{Deref}StepCount = {Int(obj.StepCount)};");
            }

            WriteObjectFactoryEnd(builder);
            return true;
        }

        bool GenerateContainerVisualFactory(CodeBuilder builder, ContainerVisual obj, ObjectData node)
        {
            WriteObjectFactoryStart(builder, node);
            WriteCreateAssignment(builder, node, $"_c{Deref}CreateContainerVisual()");
            InitializeContainerVisual(builder, obj, node);
            StartAnimations(builder, obj, node);
            WriteObjectFactoryEnd(builder);
            return true;
        }

        bool GenerateExpressionAnimationFactory(CodeBuilder builder, ExpressionAnimation obj, ObjectData node)
        {
            WriteObjectFactoryStart(builder, node);
            WriteCreateAssignment(builder, node, $"_c{Deref}CreateExpressionAnimation()");
            InitializeCompositionAnimation(builder, obj, node);
            builder.WriteLine($"result{Deref}Expression = {String(obj.Expression.ToString())};");
            StartAnimations(builder, obj, node);
            WriteObjectFactoryEnd(builder);
            return true;
        }

        void StartAnimations(CodeBuilder builder, CompositionObject obj, ObjectData node, string localName = "result", string animationNamePrefix = "")
        {
            bool controllerVariableAdded = false;

            // Start the animations for properties on the object.
            foreach (var animator in obj.Animators)
            {
                StartAnimation(builder, obj, node, localName, ref controllerVariableAdded, animator);
            }

            // Start the animations for properties on the property set.
            foreach (var animator in obj.Properties.Animators)
            {
                StartAnimation(builder, obj.Properties, NodeFor(obj.Properties), localName, ref controllerVariableAdded, animator);
            }
        }

        void StartAnimation(CodeBuilder builder, CompositionObject obj, ObjectData node, string localName, ref bool controllerVariableAdded, CompositionObject.Animator animator)
        {
            // ExpressionAnimations are treated specially - a singleton
            // ExpressionAnimation is reset before each use, unless the animation
            // is shared.
            var animationNode = NodeFor(animator.Animation);
            if (!animationNode.RequiresStorage && animator.Animation is ExpressionAnimation expressionAnimation)
            {
                builder.WriteLine($"{SingletonExpressionAnimationName}{Deref}ClearAllParameters();");
                builder.WriteLine($"{SingletonExpressionAnimationName}{Deref}Expression = {String(expressionAnimation.Expression.ToString())};");

                // If there is a Target set it. Note however that the Target isn't used for anything
                // interesting in this scenario, and there is no way to reset the Target to an
                // empty string (the Target API disallows empty). In reality, for all our uses
                // the Target will not be set and it doesn't matter if it was set previously.
                if (!string.IsNullOrWhiteSpace(expressionAnimation.Target))
                {
                    builder.WriteLine($"{SingletonExpressionAnimationName}{Deref}Target = {String(expressionAnimation.Target)};");
                }

                foreach (var rp in expressionAnimation.ReferenceParameters)
                {
                    var referenceParamenterValueName = rp.Value == obj
                        ? localName
                        : CallFactoryFromFor(animationNode, rp.Value);
                    builder.WriteLine($"{SingletonExpressionAnimationName}{Deref}SetReferenceParameter({String(rp.Key)}, {referenceParamenterValueName});");
                }

                builder.WriteLine($"{localName}{Deref}StartAnimation({String(animator.AnimatedProperty)}, {SingletonExpressionAnimationName});");
            }
            else
            {
                // KeyFrameAnimation or shared animation
                var animationFactoryCall = CallFactoryFromFor(node, animationNode);
                builder.WriteLine($"{localName}{Deref}StartAnimation({String(animator.AnimatedProperty)}, {animationFactoryCall});");
            }

            // If the animation has a controller, get the controller, optionally pause it, and recurse to start the animations
            // on the controller.
            if (animator.Controller != null)
            {
                if (!controllerVariableAdded)
                {
                    // Declare and initialize the controller variable.
                    builder.WriteLine($"{Var} controller = {localName}{Deref}TryGetAnimationController({String(animator.AnimatedProperty)});");
                    controllerVariableAdded = true;
                }
                else
                {
                    // Initialize the controller variable.
                    builder.WriteLine($"controller = {localName}{Deref}TryGetAnimationController({String(animator.AnimatedProperty)});");
                }

                if (animator.Controller.IsPaused)
                {
                    builder.WriteLine($"controller{Deref}Pause();");
                }

                // Recurse to start animations on the controller.
                StartAnimations(builder, animator.Controller, NodeFor(animator.Controller), "controller", "controller");
            }
        }

        void InitializeCompositionObject(CodeBuilder builder, CompositionObject obj, ObjectData node, string localName = "result", string animationNamePrefix = "")
        {
            if (_setCommentProperties)
            {
                if (!string.IsNullOrWhiteSpace(obj.Comment))
                {
                    builder.WriteLine($"{localName}{Deref}Comment = {String(obj.Comment)};");
                }
            }

            var propertySet = obj.Properties;
            if (!propertySet.IsEmpty)
            {
                builder.WriteLine($"{Var} propertySet = {localName}{Deref}Properties;");
                foreach (var prop in propertySet.ScalarProperties)
                {
                    builder.WriteLine($"propertySet{Deref}InsertScalar({String(prop.Key)}, {Float(prop.Value)});");
                }

                foreach (var prop in propertySet.Vector2Properties)
                {
                    builder.WriteLine($"propertySet{Deref}InsertVector2({String(prop.Key)}, {Vector2(prop.Value)});");
                }
            }
        }

        void InitializeCompositionBrush(CodeBuilder builder, CompositionBrush obj, ObjectData node)
        {
            InitializeCompositionObject(builder, obj, node);
        }

        void InitializeVisual(CodeBuilder builder, Visual obj, ObjectData node)
        {
            InitializeCompositionObject(builder, obj, node);

            if (obj.CenterPoint.HasValue)
            {
                builder.WriteLine($"result{Deref}CenterPoint = {Vector3(obj.CenterPoint.Value)};");
            }

            if (obj.Clip != null)
            {
                builder.WriteLine($"result{Deref}Clip = {CallFactoryFromFor(node, obj.Clip)};");
            }

            if (obj.Offset.HasValue)
            {
                builder.WriteLine($"result{Deref}Offset = {Vector3(obj.Offset.Value)};");
            }

            if (obj.Opacity.HasValue)
            {
                builder.WriteLine($"result{Deref}Opacity = {Float(obj.Opacity.Value)};");
            }

            if (obj.RotationAngleInDegrees.HasValue)
            {
                builder.WriteLine($"result{Deref}RotationAngleInDegrees = {Float(obj.RotationAngleInDegrees.Value)};");
            }

            if (obj.RotationAxis.HasValue)
            {
                builder.WriteLine($"result{Deref}RotationAxis = {Vector3(obj.RotationAxis.Value)};");
            }

            if (obj.Scale.HasValue)
            {
                builder.WriteLine($"result{Deref}Scale = {Vector3(obj.Scale.Value)};");
            }

            if (obj.Size.HasValue)
            {
                builder.WriteLine($"result{Deref}Size = {Vector2(obj.Size.Value)};");
            }

            if (obj.TransformMatrix.HasValue)
            {
                builder.WriteLine($"result{Deref}TransformMatrix = {Matrix4x4(obj.TransformMatrix.Value)};");
            }
        }

        void InitializeCompositionClip(CodeBuilder builder, CompositionClip obj, ObjectData node)
        {
            InitializeCompositionObject(builder, obj, node);

            if (obj.CenterPoint.X != 0 || obj.CenterPoint.Y != 0)
            {
                builder.WriteLine($"result{Deref}CenterPoint = {Vector2(obj.CenterPoint)};");
            }

            if (obj.Scale.X != 1 || obj.Scale.Y != 1)
            {
                builder.WriteLine($"result{Deref}Scale = {Vector2(obj.Scale)};");
            }
        }

        void InitializeCompositionGradientBrush(CodeBuilder builder, CompositionGradientBrush obj, ObjectData node)
        {
            InitializeCompositionObject(builder, obj, node);
            if (obj.AnchorPoint.HasValue)
            {
                builder.WriteLine($"result{Deref}AnchorPoint = {Vector2(obj.AnchorPoint.Value)};");
            }

            if (obj.CenterPoint.HasValue)
            {
                builder.WriteLine($"result{Deref}CenterPoint = {Vector2(obj.CenterPoint.Value)};");
            }

            if (obj.ColorStops.Count > 0)
            {
                builder.WriteLine($"{Var} colorStops = result{Deref}ColorStops;");
                foreach (var colorStop in obj.ColorStops)
                {
                    builder.WriteLine($"colorStops{Deref}{IListAdd}({CallFactoryFromFor(node, colorStop)});");
                }
            }

            if (obj.ExtendMode.HasValue)
            {
                builder.WriteLine($"result{Deref}ExtendMode = {ExtendMode(obj.ExtendMode.Value)};");
            }

            if (obj.InterpolationSpace.HasValue)
            {
                builder.WriteLine($"result{Deref}InterpolationSpace = {ColorSpace(obj.InterpolationSpace.Value)};");
            }

            // Default MappingMode is Relative
            if (obj.MappingMode.HasValue && obj.MappingMode.Value != WinCompData.CompositionMappingMode.Relative)
            {
                builder.WriteLine($"result{Deref}MappingMode = {MappingMode(obj.MappingMode.Value)};");
            }

            if (obj.Offset.HasValue)
            {
                builder.WriteLine($"result{Deref}Offset = {Vector2(obj.Offset.Value)}");
            }

            if (obj.RotationAngleInDegrees.HasValue)
            {
                builder.WriteLine($"result{Deref}RotationAngleInDegrees = {Float(obj.RotationAngleInDegrees.Value)}");
            }

            if (obj.Scale.HasValue)
            {
                builder.WriteLine($"result{Deref}Scale = {Vector2(obj.Scale.Value)}");
            }

            if (obj.TransformMatrix.HasValue)
            {
                builder.WriteLine($"result{Deref}TransformMatrix = {Matrix3x2(obj.TransformMatrix.Value)}");
            }
        }

        void InitializeCompositionShape(CodeBuilder builder, CompositionShape obj, ObjectData node)
        {
            InitializeCompositionObject(builder, obj, node);

            if (obj.CenterPoint.HasValue)
            {
                builder.WriteLine($"result{Deref}CenterPoint = {Vector2(obj.CenterPoint.Value)};");
            }

            if (obj.Offset != null)
            {
                builder.WriteLine($"result{Deref}Offset = {Vector2(obj.Offset.Value)};");
            }

            if (obj.RotationAngleInDegrees.HasValue)
            {
                builder.WriteLine($"result{Deref}RotationAngleInDegrees = {Float(obj.RotationAngleInDegrees.Value)};");
            }

            if (obj.Scale.HasValue)
            {
                builder.WriteLine($"result{Deref}Scale = {Vector2(obj.Scale.Value)};");
            }

            if (obj.TransformMatrix.HasValue)
            {
                builder.WriteLine($"result{Deref}TransformMatrix = {Matrix3x2(obj.TransformMatrix.Value)};");
            }
        }

        void InitializeContainerVisual(CodeBuilder builder, ContainerVisual obj, ObjectData node)
        {
            InitializeVisual(builder, obj, node);

            if (obj.Children.Any())
            {
                builder.WriteLine($"{Var} children = result{Deref}Children;");
                foreach (var child in obj.Children)
                {
                    builder.WriteLine($"children{Deref}InsertAtTop({CallFactoryFromFor(node, child)});");
                }
            }
        }

        void InitializeCompositionGeometry(CodeBuilder builder, CompositionGeometry obj, ObjectData node)
        {
            InitializeCompositionObject(builder, obj, node);

            if (obj.TrimEnd != 1)
            {
                builder.WriteLine($"result{Deref}TrimEnd = {Float(obj.TrimEnd)};");
            }

            if (obj.TrimOffset != 0)
            {
                builder.WriteLine($"result{Deref}TrimOffset = {Float(obj.TrimOffset)};");
            }

            if (obj.TrimStart != 0)
            {
                builder.WriteLine($"result{Deref}TrimStart = {Float(obj.TrimStart)};");
            }
        }

        void InitializeCompositionAnimation(CodeBuilder builder, CompositionAnimation obj, ObjectData node)
        {
            InitializeCompositionAnimationWithParameters(
                builder,
                obj,
                node,
                obj.ReferenceParameters.Select(p => new KeyValuePair<string, string>(p.Key, $"{CallFactoryFromFor(node, p.Value)}")));
        }

        void InitializeCompositionAnimationWithParameters(CodeBuilder builder, CompositionAnimation obj, ObjectData node, IEnumerable<KeyValuePair<string, string>> parameters)
        {
            InitializeCompositionObject(builder, obj, node);
            if (!string.IsNullOrWhiteSpace(obj.Target))
            {
                builder.WriteLine($"result{Deref}Target = {String(obj.Target)};");
            }

            foreach (var parameter in parameters)
            {
                builder.WriteLine($"result{Deref}SetReferenceParameter({String(parameter.Key)}, {parameter.Value});");
            }
        }

        void InitializeKeyFrameAnimation(CodeBuilder builder, KeyFrameAnimation_ obj, ObjectData node)
        {
            InitializeCompositionAnimation(builder, obj, node);
            builder.WriteLine($"result{Deref}Duration = {TimeSpan(obj.Duration)};");
        }

        bool GenerateColorKeyFrameAnimationFactory(CodeBuilder builder, ColorKeyFrameAnimation obj, ObjectData node)
        {
            WriteObjectFactoryStart(builder, node);
            WriteCreateAssignment(builder, node, $"_c{Deref}CreateColorKeyFrameAnimation()");
            InitializeKeyFrameAnimation(builder, obj, node);

            if (obj.InterpolationColorSpace != CompositionColorSpace.Auto)
            {
                builder.WriteLine($"result{Deref}InterpolationColorSpace = {ColorSpace(obj.InterpolationColorSpace)};");
            }

            foreach (var kf in obj.KeyFrames)
            {
                switch (kf.Type)
                {
                    case KeyFrameAnimation<Color>.KeyFrameType.Expression:
                        var expressionKeyFrame = (KeyFrameAnimation<Color>.ExpressionKeyFrame)kf;
                        builder.WriteLine($"result{Deref}InsertExpressionKeyFrame({Float(kf.Progress)}, {String(expressionKeyFrame.Expression)}, {CallFactoryFromFor(node, kf.Easing)});");
                        break;
                    case KeyFrameAnimation<Color>.KeyFrameType.Value:
                        var valueKeyFrame = (KeyFrameAnimation<Color>.ValueKeyFrame)kf;
                        builder.WriteComment(valueKeyFrame.Value.Name);
                        builder.WriteLine($"result{Deref}InsertKeyFrame({Float(kf.Progress)}, {Color(valueKeyFrame.Value)}, {CallFactoryFromFor(node, kf.Easing)});");
                        break;
                    default:
                        throw new InvalidOperationException();
                }
            }

            StartAnimations(builder, obj, node);
            WriteObjectFactoryEnd(builder);
            return true;
        }

        bool GenerateVector2KeyFrameAnimationFactory(CodeBuilder builder, Vector2KeyFrameAnimation obj, ObjectData node)
        {
            WriteObjectFactoryStart(builder, node);
            WriteCreateAssignment(builder, node, $"_c{Deref}CreateVector2KeyFrameAnimation()");
            InitializeKeyFrameAnimation(builder, obj, node);

            foreach (var kf in obj.KeyFrames)
            {
                switch (kf.Type)
                {
                    case KeyFrameAnimation<Vector2>.KeyFrameType.Expression:
                        var expressionKeyFrame = (KeyFrameAnimation<Vector2>.ExpressionKeyFrame)kf;
                        builder.WriteLine($"result{Deref}InsertExpressionKeyFrame({Float(kf.Progress)}, {String(expressionKeyFrame.Expression)}, {CallFactoryFromFor(node, kf.Easing)});");
                        break;
                    case KeyFrameAnimation<Vector2>.KeyFrameType.Value:
                        var valueKeyFrame = (KeyFrameAnimation<Vector2>.ValueKeyFrame)kf;
                        builder.WriteLine($"result{Deref}InsertKeyFrame({Float(kf.Progress)}, {Vector2(valueKeyFrame.Value)}, {CallFactoryFromFor(node, kf.Easing)});");
                        break;
                    default:
                        throw new InvalidOperationException();
                }
            }

            StartAnimations(builder, obj, node);
            WriteObjectFactoryEnd(builder);
            return true;
        }

        bool GenerateVector3KeyFrameAnimationFactory(CodeBuilder builder, Vector3KeyFrameAnimation obj, ObjectData node)
        {
            WriteObjectFactoryStart(builder, node);
            WriteCreateAssignment(builder, node, $"_c{Deref}CreateVector3KeyFrameAnimation()");
            InitializeKeyFrameAnimation(builder, obj, node);

            foreach (var kf in obj.KeyFrames)
            {
                switch (kf.Type)
                {
                    case KeyFrameAnimation<Vector3>.KeyFrameType.Expression:
                        var expressionKeyFrame = (KeyFrameAnimation<Vector3>.ExpressionKeyFrame)kf;
                        builder.WriteLine($"result{Deref}InsertExpressionKeyFrame({Float(kf.Progress)}, {String(expressionKeyFrame.Expression)}, {CallFactoryFromFor(node, kf.Easing)});");
                        break;
                    case KeyFrameAnimation<Vector3>.KeyFrameType.Value:
                        var valueKeyFrame = (KeyFrameAnimation<Vector3>.ValueKeyFrame)kf;
                        builder.WriteLine($"result{Deref}InsertKeyFrame({Float(kf.Progress)}, {Vector3(valueKeyFrame.Value)}, {CallFactoryFromFor(node, kf.Easing)});");
                        break;
                    default:
                        throw new InvalidOperationException();
                }
            }

            StartAnimations(builder, obj, node);
            WriteObjectFactoryEnd(builder);
            return true;
        }

        bool GeneratePathKeyFrameAnimationFactory(CodeBuilder builder, PathKeyFrameAnimation obj, ObjectData node)
        {
            WriteObjectFactoryStart(builder, node);
            WriteCreateAssignment(builder, node, $"_c{Deref}CreatePathKeyFrameAnimation()");
            InitializeKeyFrameAnimation(builder, obj, node);

            foreach (var kf in obj.KeyFrames)
            {
                var valueKeyFrame = (PathKeyFrameAnimation.ValueKeyFrame)kf;
                builder.WriteLine($"result{Deref}InsertKeyFrame({Float(kf.Progress)}, {CallFactoryFromFor(node, valueKeyFrame.Value)}, {CallFactoryFromFor(node, kf.Easing)});");
            }

            StartAnimations(builder, obj, node);
            WriteObjectFactoryEnd(builder);
            return true;
        }

        bool GenerateScalarKeyFrameAnimationFactory(CodeBuilder builder, ScalarKeyFrameAnimation obj, ObjectData node)
        {
            WriteObjectFactoryStart(builder, node);
            WriteCreateAssignment(builder, node, $"_c{Deref}CreateScalarKeyFrameAnimation()");
            InitializeKeyFrameAnimation(builder, obj, node);

            foreach (var kf in obj.KeyFrames)
            {
                switch (kf.Type)
                {
                    case KeyFrameAnimation<float>.KeyFrameType.Expression:
                        var expressionKeyFrame = (KeyFrameAnimation<float>.ExpressionKeyFrame)kf;
                        builder.WriteLine($"result{Deref}InsertExpressionKeyFrame({Float(kf.Progress)}, {String(expressionKeyFrame.Expression)}, {CallFactoryFromFor(node, kf.Easing)});");
                        break;
                    case KeyFrameAnimation<float>.KeyFrameType.Value:
                        var valueKeyFrame = (KeyFrameAnimation<float>.ValueKeyFrame)kf;
                        builder.WriteLine($"result{Deref}InsertKeyFrame({Float(kf.Progress)}, {Float(valueKeyFrame.Value)}, {CallFactoryFromFor(node, kf.Easing)});");
                        break;
                    default:
                        throw new InvalidOperationException();
                }
            }

            StartAnimations(builder, obj, node);
            WriteObjectFactoryEnd(builder);
            return true;
        }

        bool GenerateCompositionRectangleGeometryFactory(CodeBuilder builder, CompositionRectangleGeometry obj, ObjectData node)
        {
            WriteObjectFactoryStart(builder, node);
            WriteCreateAssignment(builder, node, $"_c{Deref}CreateRectangleGeometry()");
            InitializeCompositionGeometry(builder, obj, node);

            if (obj.Offset != null)
            {
                builder.WriteLine($"result{Deref}Offset = {Vector2(obj.Offset.Value)};");
            }

            builder.WriteLine($"result{Deref}Size = {Vector2(obj.Size)};");
            StartAnimations(builder, obj, node);
            WriteObjectFactoryEnd(builder);
            return true;
        }

        bool GenerateCompositionRoundedRectangleGeometryFactory(CodeBuilder builder, CompositionRoundedRectangleGeometry obj, ObjectData node)
        {
            WriteObjectFactoryStart(builder, node);
            WriteCreateAssignment(builder, node, $"_c{Deref}CreateRoundedRectangleGeometry()");
            InitializeCompositionGeometry(builder, obj, node);
            builder.WriteLine($"result{Deref}CornerRadius = {Vector2(obj.CornerRadius)};");

            if (obj.Offset != null)
            {
                builder.WriteLine($"result{Deref}Offset = {Vector2(obj.Offset.Value)};");
            }

            builder.WriteLine($"result{Deref}Size = {Vector2(obj.Size)};");
            StartAnimations(builder, obj, node);
            WriteObjectFactoryEnd(builder);
            return true;
        }

        bool GenerateCompositionEllipseGeometryFactory(CodeBuilder builder, CompositionEllipseGeometry obj, ObjectData node)
        {
            WriteObjectFactoryStart(builder, node);
            WriteCreateAssignment(builder, node, $"_c{Deref}CreateEllipseGeometry()");
            InitializeCompositionGeometry(builder, obj, node);

            if (obj.Center.X != 0 || obj.Center.Y != 0)
            {
                builder.WriteLine($"result{Deref}Center = {Vector2(obj.Center)};");
            }

            builder.WriteLine($"result{Deref}Radius = {Vector2(obj.Radius)};");
            StartAnimations(builder, obj, node);
            WriteObjectFactoryEnd(builder);
            return true;
        }

        bool GenerateCompositionPathGeometryFactory(CodeBuilder builder, CompositionPathGeometry obj, ObjectData node)
        {
            WriteObjectFactoryStart(builder, node);
            if (obj.Path == null)
            {
                WriteCreateAssignment(builder, node, $"_c{Deref}CreatePathGeometry()");
            }
            else
            {
                var path = _objectGraph[obj.Path];
                WriteCreateAssignment(builder, node, $"_c{Deref}CreatePathGeometry({CallFactoryFromFor(node, path)})");
            }

            InitializeCompositionGeometry(builder, obj, node);
            StartAnimations(builder, obj, node);
            WriteObjectFactoryEnd(builder);
            return true;
        }

        bool GenerateCompositionColorBrushFactory(CodeBuilder builder, CompositionColorBrush obj, ObjectData node)
        {
            var createCallText = $"_c{Deref}CreateColorBrush({Color(obj.Color)})";

            if (obj.Animators.Count > 0)
            {
                WriteObjectFactoryStart(builder, node);
                WriteCreateAssignment(builder, node, createCallText);
                InitializeCompositionBrush(builder, obj, node);
                StartAnimations(builder, obj, node);
                WriteObjectFactoryEnd(builder);
            }
            else
            {
                WriteSimpleObjectFactory(builder, node, createCallText);
            }

            return true;
        }

        bool GenerateCompositionColorGradientStopFactory(CodeBuilder builder, CompositionColorGradientStop obj, ObjectData node)
        {
            if (obj.Animators.Count > 0)
            {
                WriteObjectFactoryStart(builder, node);
                WriteCreateAssignment(builder, node, $"_c{Deref}CreateColorGradientStop()");
                InitializeCompositionObject(builder, obj, node);
                StartAnimations(builder, obj, node);
                WriteObjectFactoryEnd(builder);
            }
            else
            {
                WriteSimpleObjectFactory(builder, node, $"_c{Deref}CreateColorGradientStop({Float(obj.Offset)}, {Color(obj.Color)})");
            }

            return true;
        }

        bool GenerateShapeVisualFactory(CodeBuilder builder, ShapeVisual obj, ObjectData node)
        {
            WriteObjectFactoryStart(builder, node);
            WriteCreateAssignment(builder, node, $"_c{Deref}CreateShapeVisual()");
            InitializeContainerVisual(builder, obj, node);

            if (obj.Shapes.Count > 0)
            {
                builder.WriteLine($"{Var} shapes = result{Deref}Shapes;");
                foreach (var shape in obj.Shapes)
                {
                    builder.WriteComment(shape.ShortDescription);
                    builder.WriteLine($"shapes{Deref}{IListAdd}({CallFactoryFromFor(node, shape)});");
                }
            }

            StartAnimations(builder, obj, node);
            WriteObjectFactoryEnd(builder);
            return true;
        }

        bool GenerateSpriteVisualFactory(CodeBuilder builder, SpriteVisual obj, ObjectData node)
        {
            WriteObjectFactoryStart(builder, node);
            WriteCreateAssignment(builder, node, $"_c{Deref}CreateSpriteVisual()");
            InitializeContainerVisual(builder, obj, node);

            if (obj.Brush != null)
            {
                builder.WriteLine($"result{Deref}Brush = {CallFactoryFromFor(node, obj.Brush)};");
            }

            StartAnimations(builder, obj, node);
            WriteObjectFactoryEnd(builder);
            return true;
        }

        bool GenerateContainerShapeFactory(CodeBuilder builder, CompositionContainerShape obj, ObjectData node)
        {
            WriteObjectFactoryStart(builder, node);
            WriteCreateAssignment(builder, node, $"_c{Deref}CreateContainerShape()");
            InitializeCompositionShape(builder, obj, node);

            if (obj.Shapes.Count > 0)
            {
                builder.WriteLine($"{Var} shapes = result{Deref}Shapes;");
                foreach (var shape in obj.Shapes)
                {
                    builder.WriteLine($"shapes{Deref}{IListAdd}({CallFactoryFromFor(node, shape)});");
                }
            }

            StartAnimations(builder, obj, node);
            WriteObjectFactoryEnd(builder);
            return true;
        }

        bool GenerateCompositionEffectBrushFactory(CodeBuilder builder, CompositionEffectBrush obj, ObjectData node)
        {
            WriteObjectFactoryStart(builder, node);

            var effect = obj.GetEffect();

            string effectCreationString;
            switch (effect.Type)
            {
                case Mgce.GraphicsEffectType.CompositeEffect:
                    effectCreationString = WriteCompositeEffectFactory(builder, (Mgce.CompositeEffect)effect);
                    break;
                default:
                    // Unsupported GraphicsEffectType.
                    throw new InvalidOperationException();
            }

            builder.WriteLine($"{Var} effectFactory = _c{Deref}CreateEffectFactory({effectCreationString});");
            WriteCreateAssignment(builder, node, $"effectFactory{Deref}CreateBrush()");
            InitializeCompositionBrush(builder, obj, node);

            // Perform brush initialization
            switch (effect.Type)
            {
                case Mgce.GraphicsEffectType.CompositeEffect:
                    foreach (var sourceParameters in ((Mgce.CompositeEffect)effect).Sources)
                    {
                        builder.WriteLine($"result{Deref}SetSourceParameter({String(sourceParameters.Name)}, {CallFactoryFromFor(node, obj.GetSourceParameter(sourceParameters.Name))});");
                    }

                    break;
                default:
                    throw new InvalidOperationException();
            }

            StartAnimations(builder, obj, node);
            WriteObjectFactoryEnd(builder);
            return true;
        }

        bool GenerateSpriteShapeFactory(CodeBuilder builder, CompositionSpriteShape obj, ObjectData node)
        {
            WriteObjectFactoryStart(builder, node);
            WriteCreateAssignment(builder, node, $"_c{Deref}CreateSpriteShape()");
            InitializeCompositionShape(builder, obj, node);

            if (obj.FillBrush != null)
            {
                builder.WriteLine($"result{Deref}FillBrush = {CallFactoryFromFor(node, obj.FillBrush)};");
            }

            if (obj.Geometry != null)
            {
                builder.WriteLine($"result{Deref}Geometry = {CallFactoryFromFor(node, obj.Geometry)};");
            }

            if (obj.IsStrokeNonScaling)
            {
                builder.WriteLine("result{Deref}IsStrokeNonScaling = true;");
            }

            if (obj.StrokeBrush != null)
            {
                builder.WriteLine($"result{Deref}StrokeBrush = {CallFactoryFromFor(node, obj.StrokeBrush)};");
            }

            if (obj.StrokeDashCap != CompositionStrokeCap.Flat)
            {
                builder.WriteLine($"result{Deref}StrokeDashCap = {StrokeCap(obj.StrokeDashCap)};");
            }

            if (obj.StrokeDashOffset != 0)
            {
                builder.WriteLine($"result{Deref}StrokeDashOffset = {Float(obj.StrokeDashOffset)};");
            }

            if (obj.StrokeDashArray.Count > 0)
            {
                builder.WriteLine($"{Var} strokeDashArray = result{Deref}StrokeDashArray;");
                foreach (var strokeDash in obj.StrokeDashArray)
                {
                    builder.WriteLine($"strokeDashArray{Deref}{IListAdd}({Float(strokeDash)});");
                }
            }

            if (obj.StrokeEndCap != CompositionStrokeCap.Flat)
            {
                builder.WriteLine($"result{Deref}StrokeEndCap = {StrokeCap(obj.StrokeEndCap)};");
            }

            if (obj.StrokeLineJoin != CompositionStrokeLineJoin.Miter)
            {
                builder.WriteLine($"result{Deref}StrokeLineJoin = {StrokeLineJoin(obj.StrokeLineJoin)};");
            }

            if (obj.StrokeStartCap != CompositionStrokeCap.Flat)
            {
                builder.WriteLine($"result{Deref}StrokeStartCap = {StrokeCap(obj.StrokeStartCap)};");
            }

            if (obj.StrokeMiterLimit != 1)
            {
                builder.WriteLine($"result{Deref}StrokeMiterLimit = {Float(obj.StrokeMiterLimit)};");
            }

            if (obj.StrokeThickness != 1)
            {
                builder.WriteLine($"result{Deref}StrokeThickness = {Float(obj.StrokeThickness)};");
            }

            StartAnimations(builder, obj, node);
            WriteObjectFactoryEnd(builder);
            return true;
        }

        bool GenerateCompositionSurfaceBrushFactory(CodeBuilder builder, CompositionSurfaceBrush obj, ObjectData node)
        {
            WriteObjectFactoryStart(builder, node);
            WriteCreateAssignment(builder, node, $"_c{Deref}CreateSurfaceBrush()");
            InitializeCompositionBrush(builder, obj, node);

            if (obj.Surface != null)
            {
                switch (obj.Surface)
                {
                    case CompositionObject compositionObject:
                        builder.WriteLine($"result{Deref}Surface = {CallFactoryFromFor(node, compositionObject)};");
                        break;
                    case Wmd.LoadedImageSurface loadedImageSurface:
                        builder.WriteLine($"result{Deref}Surface = {NodeFor(loadedImageSurface).FieldName};");
                        break;
                    default:
                        throw new InvalidOperationException();
                }
            }

            StartAnimations(builder, obj, node);
            WriteObjectFactoryEnd(builder);
            return true;
        }

        bool GenerateCompositionViewBoxFactory(CodeBuilder builder, CompositionViewBox obj, ObjectData node)
        {
            WriteObjectFactoryStart(builder, node);
            WriteCreateAssignment(builder, node, $"_c{Deref}CreateViewBox()");
            InitializeCompositionObject(builder, obj, node);
            builder.WriteLine($"result.Size = {Vector2(obj.Size)};");
            StartAnimations(builder, obj, node);
            WriteObjectFactoryEnd(builder);
            return true;
        }

        bool GenerateCompositionVisualSurfaceFactory(CodeBuilder builder, CompositionVisualSurface obj, ObjectData node)
        {
            WriteObjectFactoryStart(builder, node);
            WriteCreateAssignment(builder, node, $"_c{Deref}CreateVisualSurface()");
            InitializeCompositionObject(builder, obj, node);

            if (obj.SourceVisual != null)
            {
                builder.WriteLine($"result{Deref}SourceVisual = {CallFactoryFromFor(node, obj.SourceVisual)};");
            }

            if (obj.SourceSize != null)
            {
                builder.WriteLine($"result{Deref}SourceSize = {Vector2(obj.SourceSize.Value)};");
            }

            if (obj.SourceOffset != null)
            {
                builder.WriteLine($"result{Deref}SourceOffset = {Vector2(obj.SourceOffset.Value)};");
            }

            StartAnimations(builder, obj, node);
            WriteObjectFactoryEnd(builder);
            return true;
        }

        bool GenerateCompositionPathFactory(CodeBuilder builder, CompositionPath obj, ObjectData node)
        {
            var canvasGeometry = _objectGraph[(CanvasGeometry)obj.Source];
            WriteObjectFactoryStart(builder, node);
            WriteCreateAssignment(builder, node, $"{New} CompositionPath({_stringifier.FactoryCall(canvasGeometry.FactoryCall())})");
            WriteObjectFactoryEnd(builder);
            return true;
        }

        void WriteCreateAssignment(CodeBuilder builder, ObjectData node, string createCallText)
        {
            if (node.RequiresStorage)
            {
                if (_disableFieldOptimization)
                {
                    // If the field has already been assigned, return its value.
                    builder.WriteLine($"if ({node.FieldName} != {Null}) {{ return {node.FieldName}; }}");
                }

                builder.WriteLine($"{Var} result = {node.FieldName} = {createCallText};");
            }
            else
            {
                builder.WriteLine($"{Var} result = {createCallText};");
            }
        }

        // Handles object factories that are just a create call.
        void WriteSimpleObjectFactory(CodeBuilder builder, ObjectData node, string createCallText)
        {
            builder.WriteComment(node.LongComment);
            WriteObjectFactoryStartWithoutCache(builder, node);
            if (node.RequiresStorage)
            {
                builder.WriteLine($"return {node.FieldName} = {createCallText};");
            }
            else
            {
                builder.WriteLine($"return {createCallText};");
            }

            builder.CloseScope();
            builder.WriteLine();
        }

        void WriteObjectFactoryStart(CodeBuilder builder, ObjectData node, IEnumerable<string> parameters = null)
        {
            builder.WriteComment(node.LongComment);
            WriteObjectFactoryStartWithoutCache(builder, node, parameters);
        }

        void WriteObjectFactoryStartWithoutCache(CodeBuilder builder, ObjectData node, IEnumerable<string> parameters = null)
        {
            // Save the node as the current node while the factory is being written.
            _currentObjectFactoryNode = node;
            builder.WriteLine($"{_stringifier.ReferenceTypeName(node.TypeName)} {node.Name}({(parameters == null ? string.Empty : string.Join(", ", parameters))})");
            builder.OpenScope();
        }

        void WriteObjectFactoryEnd(CodeBuilder builder)
        {
            builder.WriteLine("return result;");
            builder.CloseScope();
            builder.WriteLine();
            _currentObjectFactoryNode = null;
        }

        string Const(string value) => _stringifier.Const(value);

        string Deref => _stringifier.Deref;

        string New => _stringifier.New;

        string Null => _stringifier.Null;

        string ScopeResolve => _stringifier.ScopeResolve;

        string Var => _stringifier.Var;

        string Bool(bool value) => _stringifier.Bool(value);

        string Color(Color value) => _stringifier.Color(value);

        string IListAdd => _stringifier.IListAdd;

        string CanvasFigureLoop(CanvasFigureLoop value) => _stringifier.CanvasFigureLoop(value);

        string CanvasGeometryCombine(CanvasGeometryCombine value) => _stringifier.CanvasGeometryCombine(value);

        string FilledRegionDetermination(CanvasFilledRegionDetermination value) => _stringifier.FilledRegionDetermination(value);

        string Float(float value) => _stringifier.Float(value);

        // A float for use in an id.
        static string FloatId(float value) => value.ToString("0.###", CultureInfo.InvariantCulture).Replace('.', 'p').Replace('-', 'm');

        string Int(int value) => _stringifier.Int32(value);

        string Int64(long value) => _stringifier.Int64(value);

        string Matrix3x2(Matrix3x2 value) => _stringifier.Matrix3x2(value);

        string Matrix4x4(Matrix4x4 value) => _stringifier.Matrix4x4(value);

        // readonly on C#, const on C++.
        string Readonly(string value) => _stringifier.Readonly(value);

        string String(string value) => _stringifier.String(value);

        string ColorSpace(CompositionColorSpace value)
        {
            const string typeName = nameof(CompositionColorSpace);
            switch (value)
            {
                case CompositionColorSpace.Auto:
                    return $"{typeName}{ScopeResolve}Auto";
                case CompositionColorSpace.Hsl:
                    return $"{typeName}{ScopeResolve}Hsl";
                case CompositionColorSpace.Rgb:
                    return $"{typeName}{ScopeResolve}Rgb";
                case CompositionColorSpace.HslLinear:
                    return $"{typeName}{ScopeResolve}HslLinear";
                case CompositionColorSpace.RgbLinear:
                    return $"{typeName}{ScopeResolve}RgbLinear";
                default:
                    throw new InvalidOperationException();
            }
        }

        string StrokeCap(CompositionStrokeCap value)
        {
            const string typeName = nameof(CompositionStrokeCap);
            switch (value)
            {
                case CompositionStrokeCap.Flat:
                    return $"{typeName}{ScopeResolve}Flat";
                case CompositionStrokeCap.Square:
                    return $"{typeName}{ScopeResolve}Square";
                case CompositionStrokeCap.Round:
                    return $"{typeName}{ScopeResolve}Round";
                case CompositionStrokeCap.Triangle:
                    return $"{typeName}{ScopeResolve}Triangle";
                default:
                    throw new InvalidOperationException();
            }
        }

        string StrokeLineJoin(CompositionStrokeLineJoin value)
        {
            const string typeName = nameof(CompositionStrokeLineJoin);
            switch (value)
            {
                case CompositionStrokeLineJoin.Miter:
                    return $"{typeName}{ScopeResolve}Miter";
                case CompositionStrokeLineJoin.Bevel:
                    return $"{typeName}{ScopeResolve}Bevel";
                case CompositionStrokeLineJoin.Round:
                    return $"{typeName}{ScopeResolve}Round";
                case CompositionStrokeLineJoin.MiterOrBevel:
                    return $"{typeName}{ScopeResolve}MiterOrBevel";
                default:
                    throw new InvalidOperationException();
            }
        }

        string ExtendMode(CompositionGradientExtendMode value)
        {
            const string typeName = nameof(CompositionGradientExtendMode);
            switch (value)
            {
                case CompositionGradientExtendMode.Clamp:
                    return $"{typeName}{ScopeResolve}Clamp";
                case CompositionGradientExtendMode.Wrap:
                    return $"{typeName}{ScopeResolve}Wrap";
                case CompositionGradientExtendMode.Mirror:
                    return $"{typeName}{ScopeResolve}Mirror";
                default:
                    throw new InvalidOperationException();
            }
        }

        string MappingMode(CompositionMappingMode value)
        {
            const string typeName = nameof(CompositionMappingMode);
            switch (value)
            {
                case CompositionMappingMode.Absolute:
                    return $"{typeName}{ScopeResolve}Absolute";
                case CompositionMappingMode.Relative:
                    return $"{typeName}{ScopeResolve}Relative";
                default:
                    throw new InvalidOperationException();
            }
        }

        string TimeSpan(TimeSpan value) => value == _compositionDuration ? _stringifier.TimeSpan(DurationTicksFieldName) : _stringifier.TimeSpan(value);

        string Vector2(Vector2 value) => _stringifier.Vector2(value);

        // A Vector2 for use in an id.
        static string Vector2Id(Vector2 size)
        {
            return size.X == size.Y
                ? FloatId(size.X)
                : $"{FloatId(size.X)}x{FloatId(size.Y)}";
        }

        string Vector3(Vector3 value) => _stringifier.Vector3(value);

        /// <summary>
        /// Holds information about the code being generated.
        /// </summary>
        protected internal sealed class CodeGenInfo
        {
            internal CodeGenInfo(
                string className,
                string reusableExpressionAnimationFieldName,
                string durationTicksFieldName,
                Vector2 compositionDeclaredSize,
                Visual rootVisual,
                bool usesCanvas,
                bool usesCanvasEffects,
                bool usesCanvasGeometry,
                bool usesNamespaceWindowsUIXamlMedia,
                bool usesStreams,
                bool hasLoadedImageSurface,
                bool usesCompositeEffect,
                IEnumerable<LoadedImageSurfaceNode> loadedImageSurfaceNodes)
            {
                ClassName = className;
                ReusableExpressionAnimationFieldName = reusableExpressionAnimationFieldName;
                DurationTicksFieldName = durationTicksFieldName;
                CompositionDeclaredSize = compositionDeclaredSize;
                RootVisual = rootVisual;
                UsesCanvas = usesCanvas;
                UsesCanvasEffects = usesCanvasEffects;
                UsesCanvasGeometry = usesCanvasGeometry;
                UsesNamespaceWindowsUIXamlMedia = usesNamespaceWindowsUIXamlMedia;
                UsesStreams = usesStreams;
                HasLoadedImageSurface = hasLoadedImageSurface;
                UsesCompositeEffect = usesCompositeEffect;
                LoadedImageSurfaceNodes = loadedImageSurfaceNodes;
            }

            /// <summary>
            /// Gets the name of the class that will be exposed to users.
            /// </summary>
            public string ClassName { get; }

            /// <summary>
            /// Gets the name of the field in the instantiator class that hold the reusable ExpressionAnimation.
            /// </summary>
            public string ReusableExpressionAnimationFieldName { get; }

            /// <summary>
            /// Gets the constant holding the duration of the composition in ticks.
            /// </summary>
            public string DurationTicksFieldName { get; }

            /// <summary>
            /// Gets the declared size of the composition.
            /// </summary>
            public Vector2 CompositionDeclaredSize { get; }

            /// <summary>
            /// Gets the Visual at the root of the composition.
            /// </summary>
            public Visual RootVisual { get; }

            /// <summary>
            /// Gets a value indicating whether the composition depends on the Microsoft.Graphics.Canvas namespace.
            /// </summary>
            public bool UsesCanvas { get; }

            /// <summary>
            /// Gets a value indicating whether the composition depends on the Microsoft.Graphics.Canvas.Effects namespace.
            /// </summary>
            public bool UsesCanvasEffects { get; }

            /// <summary>
            /// Gets a value indicating whether the composition depends on the Microsoft.Graphics.Canvas.Geometry namespace.
            /// </summary>
            public bool UsesCanvasGeometry { get; }

            /// <summary>
            /// Gets a value indicating whether the composition uses the Windows.UI.Xaml.Media namespace.
            /// </summary>
            public bool UsesNamespaceWindowsUIXamlMedia { get; }

            /// <summary>
            /// Gets a value indicating whether the composition uses streams.
            /// </summary>
            public bool UsesStreams { get; }

            /// <summary>
            /// Gets a value indicating whether the composition has LoadedImageSurface.
            /// </summary>
            public bool HasLoadedImageSurface { get; }

            /// <summary>
            /// Gets the LoadedImageSurface nodes of the composition.
            /// </summary>
            public IEnumerable<LoadedImageSurfaceNode> LoadedImageSurfaceNodes { get; }

            /// <summary>
            /// Gets a value indicating whether the composition depends on a composite effect.
            /// </summary>
            public bool UsesCompositeEffect { get; }
        }

        // Provides language-specific string representations of a value.
        protected internal interface IStringifier
        {
            string Bool(bool value);

            string CanvasFigureLoop(CanvasFigureLoop value);

            string CanvasGeometryCombine(CanvasGeometryCombine value);

            string Color(Color value);

            string Deref { get; }

            string FilledRegionDetermination(CanvasFilledRegionDetermination value);

            string Float(float value);

            string IListAdd { get; }

            string FactoryCall(string value);

            string Int32(int value);

            string Int64(long value);

            string Int32TypeName { get; }

            string Int64TypeName { get; }

            string Matrix3x2(Matrix3x2 value);

            string Matrix4x4(Matrix4x4 value);

            string MemberSelect { get; }

            string New { get; }

            string Null { get; }

            string Readonly(string value);

            string ReferenceTypeName(string value);

            string ScopeResolve { get; }

            string String(string value);

            string TimeSpan(TimeSpan value);

            string TimeSpan(string ticks);

            string Var { get; }

            string Vector2(Vector2 value);

            string Vector3(Vector3 value);

            string Static { get; }

            string ByteArray { get; }

            string Const(string value);

            string CanvasCompositeMode(CanvasComposite value);
        }

        /// <summary>
        /// A stringifier implementation for some common string formats that are shared
        /// by most languages.
        /// </summary>
        protected internal abstract class StringifierBase : IStringifier
        {
            /// <inheritdoc/>
            public abstract string Deref { get; }

            /// <inheritdoc/>
            public abstract string IListAdd { get; }

            /// <inheritdoc/>
            public virtual string Int32TypeName => "int";

            /// <inheritdoc/>
            public abstract string Int64TypeName { get; }

            /// <inheritdoc/>
            public virtual string MemberSelect => ".";

            /// <inheritdoc/>
            public abstract string New { get; }

            /// <inheritdoc/>
            public abstract string Null { get; }

            /// <inheritdoc/>
            public abstract string Readonly(string value);

            /// <inheritdoc/>
            public abstract string ScopeResolve { get; }

            /// <inheritdoc/>
            public abstract string Var { get; }

            /// <inheritdoc/>
            public virtual string Bool(bool value) => value ? "true" : "false";

            /// <inheritdoc/>
            public abstract string CanvasFigureLoop(CanvasFigureLoop value);

            /// <inheritdoc/>
            public abstract string CanvasGeometryCombine(CanvasGeometryCombine value);

            /// <inheritdoc/>
            public abstract string Color(Color value);

            /// <inheritdoc/>
            public abstract string FactoryCall(string value);

            /// <inheritdoc/>
            public abstract string FilledRegionDetermination(CanvasFilledRegionDetermination value);

            /// <inheritdoc/>
            public virtual string Float(float value) =>
                Math.Floor(value) == value
                    ? value.ToString("0", CultureInfo.InvariantCulture)
                    : value.ToString("G9", CultureInfo.InvariantCulture) + "F";

            /// <inheritdoc/>
            public virtual string Int32(int value) => value.ToString();

            /// <inheritdoc/>
            public abstract string Int64(long value);

            /// <inheritdoc/>
            public abstract string Matrix3x2(Matrix3x2 value);

            /// <inheritdoc/>
            public abstract string Matrix4x4(Matrix4x4 value);

            /// <inheritdoc/>
            public abstract string ReferenceTypeName(string value);

            /// <inheritdoc/>
            public virtual string String(string value) => $"\"{value}\"";

            /// <inheritdoc/>
            public abstract string TimeSpan(TimeSpan value);

            /// <inheritdoc/>
            public abstract string TimeSpan(string ticks);

            /// <inheritdoc/>
            public abstract string Vector2(Vector2 value);

            /// <inheritdoc/>
            public abstract string Vector3(Vector3 value);

            public string Hex(int value) => $"0x{value.ToString("X2")}";

            public string Static => "static";

            public abstract string ByteArray { get; }

            public string Const(string value) => $"const {value}";

            // Sets the first character to lower case.
            public string CamelCase(string value) => $"{char.ToLowerInvariant(value[0])}{value.Substring(1)}";

            public string CanvasCompositeMode(CanvasComposite value)
            {
                var typeName = nameof(CanvasComposite);
                switch (value)
                {
                    case CanvasComposite.SourceOver:
                        return $"{typeName}{ScopeResolve}SourceOver";
                    case CanvasComposite.DestinationOver:
                        return $"{typeName}{ScopeResolve}DestinationOver";
                    case CanvasComposite.SourceIn:
                        return $"{typeName}{ScopeResolve}SourceIn";
                    case CanvasComposite.DestinationIn:
                        return $"{typeName}{ScopeResolve}DestinationIn";
                    case CanvasComposite.SourceOut:
                        return $"{typeName}{ScopeResolve}SourceOut";
                    case CanvasComposite.DestinationOut:
                        return $"{typeName}{ScopeResolve}DestinationOut";
                    case CanvasComposite.SourceAtop:
                        return $"{typeName}{ScopeResolve}SourceAtop";
                    case CanvasComposite.DestinationAtop:
                        return $"{typeName}{ScopeResolve}DestinationAtop";
                    case CanvasComposite.Xor:
                        return $"{typeName}{ScopeResolve}Xor";
                    case CanvasComposite.Add:
                        return $"{typeName}{ScopeResolve}Add";
                    case CanvasComposite.Copy:
                        return $"{typeName}{ScopeResolve}Copy";
                    case CanvasComposite.BoundedCopy:
                        return $"{typeName}{ScopeResolve}BoundedCopy";
                    case CanvasComposite.MaskInvert:
                        return $"{typeName}{ScopeResolve}MaskInvert";
                    default:
                        throw new InvalidOperationException();
                }
            }
        }

        // A node in the object graph, annotated with extra stuff to assist in code generation.
        sealed class ObjectData : Graph.Node<ObjectData>
        {
            string _overriddenFactoryCall;
            Dictionary<ObjectData, string> _callFactoryFromForCache;

            public Dictionary<ObjectData, string> CallFactoryFromForCache
            {
                get
                {
                    // Lazy initialization because not all nodes need the cache.
                    if (_callFactoryFromForCache == null)
                    {
                        _callFactoryFromForCache = new Dictionary<ObjectData, string>();
                    }

                    return _callFactoryFromForCache;
                }
            }

            public string Name { get; set; }

            public string FieldName => RequiresStorage ? CamelCase(Name) : null;

            // Returns text for obtaining the value for this node. If the node has
            // been inlined, this can generate the code into the returned string, otherwise
            // it returns code for calling the factory.
            internal string FactoryCall()
            {
                if (Inlined)
                {
                    return _overriddenFactoryCall;
                }
                else
                {
                    return $"{Name}()";
                }
            }

            IEnumerable<string> GetAncestorShortComments()
            {
                // Get the nodes that reference this node.
                var parents = InReferences.Select(v => v.Node).ToArray();
                if (parents.Length == 1)
                {
                    // There is exactly one parent.
                    if (string.IsNullOrWhiteSpace(parents[0].ShortComment))
                    {
                        // Parent has no comment.
                        yield break;
                    }

                    foreach (var ancestorShortcomment in parents[0].GetAncestorShortComments())
                    {
                        yield return ancestorShortcomment;
                    }

                    yield return parents[0].ShortComment;
                }
            }

            internal string LongComment
            {
                get
                {
                    // Prepend the ancestor nodes.
                    var sb = new StringBuilder();
                    var ancestorIndent = 0;
                    foreach (var ancestorComment in GetAncestorShortComments())
                    {
                        sb.Append(new string(' ', ancestorIndent));
                        sb.AppendLine(ancestorComment);
                        ancestorIndent += 2;
                    }

                    sb.Append(((IDescribable)Object).LongDescription);

                    return sb.ToString();
                }
            }

            internal string ShortComment => ((IDescribable)Object).ShortDescription;

            // True if the object is referenced from more than one method and
            // therefore must be stored after it is created.
            internal bool RequiresStorage { get; set; }

            // True if the object must be stored as read-only after it is created.
            internal bool RequiresReadonlyStorage { get; set; }

            // Set to indicate that the node relies on Microsoft.Graphics.Canvas namespace
            internal bool UsesCanvas => Object is CompositionEffectBrush;

            // Set to indicate that the node relies on Microsoft.Graphics.Canvas.Effects namespace
            internal bool UsesCanvasEffects => Object is CompositionEffectBrush;

            // Set to indicate that the node relies on Microsoft.Graphics.Canvas.Geometry namespace
            internal bool UsesCanvasGeometry => Object is CanvasGeometry;

            // Set to indicate that the node is a LoadedImageSurface.
            internal bool IsLoadedImageSurface => Object is Wmd.LoadedImageSurface;

            // Set to indicate that the node uses the Windows.UI.Xaml.Media namespace.
            internal bool UsesNamespaceWindowsUIXamlMedia => IsLoadedImageSurface;

            // Set to indicate that the node uses stream(s).
            internal bool UsesStream => Object is Wmd.LoadedImageSurface lis && lis.Type == Wmd.LoadedImageSurface.LoadedImageSurfaceType.FromStream;

            // Set to indicate that the node uses asset file(s).
            internal bool UsesAssetFile => Object is Wmd.LoadedImageSurface lis && lis.Type == Wmd.LoadedImageSurface.LoadedImageSurfaceType.FromUri;

            // Set to indicate that the composition depends on a composite effect.
            internal bool UsesCompositeEffect => Object is CompositionEffectBrush compositeEffectBrush && compositeEffectBrush.GetEffect().Type == Mgce.GraphicsEffectType.CompositeEffect;

            // Identifies the byte array of a LoadedImageSurface.
            internal string LoadedImageSurfaceBytesFieldName => $"s_{Name}_Bytes";

            internal Uri LoadedImageSurfaceImageUri { get; set; }

            // True if the code to create the object will be generated inline.
            internal bool Inlined => _overriddenFactoryCall != null;

            internal void ForceInline(string replacementFactoryCall)
            {
                _overriddenFactoryCall = replacementFactoryCall;
            }

            // The name of the type of the object described by this node.
            // This is the name used as the return type of a factory method.
            internal string TypeName
            {
                get
                {
                    switch (Type)
                    {
                        case Graph.NodeType.CompositionObject:
                            return ((CompositionObject)Object).Type.ToString();
                        case Graph.NodeType.CompositionPath:
                            return "CompositionPath";
                        case Graph.NodeType.CanvasGeometry:
                            return "CanvasGeometry";
                        case Graph.NodeType.LoadedImageSurface:
                            return "LoadedImageSurface";
                        default:
                            throw new InvalidOperationException();
                    }
                }
            }

            // For debugging purposes only.
            public override string ToString() => Name == null ? $"{TypeName} {InReferences.Length}" : $"{Name} {InReferences.Length}";

            // Sets the first character to lower case.
            static string CamelCase(string value) => $"_{char.ToLowerInvariant(value[0])}{value.Substring(1)}";
        }

        /// <summary>
        /// A struct for representing the LoadedImageSurface objects in the composition.
        /// </summary>
        protected internal readonly struct LoadedImageSurfaceNode
        {
            public string TypeName { get; }

            public string Name { get; }

            public string FieldName { get; }

            public string BytesFieldName { get; }

            public Uri ImageUri { get; }

            public Wmd.LoadedImageSurface.LoadedImageSurfaceType LoadedImageSurfaceType { get; }

            public LoadedImageSurfaceNode(string typeName, string name, string fieldName, string bytesFieldName, Uri imageUri, Wmd.LoadedImageSurface.LoadedImageSurfaceType loadedImageSurfaceType)
            {
                TypeName = typeName;
                Name = name;
                FieldName = fieldName;
                BytesFieldName = bytesFieldName;
                ImageUri = imageUri;
                LoadedImageSurfaceType = loadedImageSurfaceType;
            }
        }
    }
}
